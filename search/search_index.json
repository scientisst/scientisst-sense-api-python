{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"scientisst-sense-api-python The ScientISST SENSE Python API. Here you can find everything about this Python API: Installation Getting Started Reference","title":"Home"},{"location":"#scientisst-sense-api-python","text":"The ScientISST SENSE Python API. Here you can find everything about this Python API: Installation Getting Started Reference","title":"scientisst-sense-api-python"},{"location":"installation/","text":"Installation Clone the Repo # Getting this repository git clone https://github.com/scientisst/scientisst-sense-api-python.git Dependencies API: PySerial Sense: pylsl pydbus Plot: numpy matplotlib Install them using pip : pip install -r requirements.txt Start having fun!","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#clone-the-repo","text":"# Getting this repository git clone https://github.com/scientisst/scientisst-sense-api-python.git","title":"Clone the Repo"},{"location":"installation/#dependencies","text":"API: PySerial Sense: pylsl pydbus Plot: numpy matplotlib Install them using pip : pip install -r requirements.txt Start having fun!","title":"Dependencies"},{"location":"getting-started/api/","text":"Examples Connect to Device The following code creates a Scientisst object and establishes a connection to the specified device. scientisst = ScientISST ( \"08:3A:F2:49:AB:DE\" ) Print Version The following code prints the firmware version of the device connected with the previous command. scientisst . version () Acquisition The following snippet starts streaming data from channels A1 , A2 , and A3 at 100 Hz. Then, it reads the streaming data (by default, for frequencies not too high, 5 times per second) and prints the first Frame . After reading 1000 frames, it stops the acquisition. scientisst . start ( 100 , [ 1 , 2 , 3 ]) for i in range ( 50 ): frames = scientisst . read () print ( frames [ 0 ]) scientisst . stop () Disconnect Once you no longer want to use the ScientISST device, you must dispose it: scientisst . disconnect ()","title":"API"},{"location":"getting-started/api/#examples","text":"","title":"Examples"},{"location":"getting-started/api/#connect-to-device","text":"The following code creates a Scientisst object and establishes a connection to the specified device. scientisst = ScientISST ( \"08:3A:F2:49:AB:DE\" )","title":"Connect to Device"},{"location":"getting-started/api/#print-version","text":"The following code prints the firmware version of the device connected with the previous command. scientisst . version ()","title":"Print Version"},{"location":"getting-started/api/#acquisition","text":"The following snippet starts streaming data from channels A1 , A2 , and A3 at 100 Hz. Then, it reads the streaming data (by default, for frequencies not too high, 5 times per second) and prints the first Frame . After reading 1000 frames, it stops the acquisition. scientisst . start ( 100 , [ 1 , 2 , 3 ]) for i in range ( 50 ): frames = scientisst . read () print ( frames [ 0 ]) scientisst . stop ()","title":"Acquisition"},{"location":"getting-started/api/#disconnect","text":"Once you no longer want to use the ScientISST device, you must dispose it: scientisst . disconnect ()","title":"Disconnect"},{"location":"getting-started/sense/","text":"sense.py is a script that simplifies the interaction with the ScientISST Sense. It allows the selection of channels, sampling rate, and duration right from the command line. It also implements file data saving in the background (using a different thread) and also streaming via Lab Streaming Layer (LSL). Usage Options $ python sense.py -h usage: sense.py [args] address description: The program connects to the ScientISST Sense device and starts an acquisition, providing the option to store the received data in a .csv file. positional arguments: address Linux: bluetooth MAC address, Mac: serial port address, Windows: bluetooth serial COM port options: -h, --help show this help message and exit -f FS, --frequency FS sampling frequency, default: 1000 -c CHANNELS, --channels CHANNELS analog channels, default: 1,2,3,4,5,6 -d DURATION, --duration DURATION duration in seconds, default: unlimited -o OUTPUT, --output OUTPUT write report to output file, default: None -r, --raw do not convert from raw to mV -s, --lsl stream data using Lab Streaming Layer protocol. Use `python -m pylsl.examples.ReceiveAndPlot` to view stream -q, --quiet don't print ScientISST frames -v, --version show sense.py version --verbose log sent/received bytes Automatic Selection Pair your device Run: python sense.py Select the device from the list displayed: ScientISST devices: [1] ScientISST-ab-de - 08:3A:F2:49:AB:DE [2] ScientISST-ac-be - 08:3A:F2:49:AC:BE Connect to: Then hit CTRL-C when you wish to stop. Manual Selection Linux Pair and trust the ScientISST Sense board: bluetoothctl scan on pair XX:XX:XX:XX:XX trust XX:XX:XX:XX:XX You can now run the sense.py script: python sense.py XX:XX:XX:XX:XX Mac First, you need to pair the ScientISST sense device in the Bluetooth Settings section. Then, you'll need to find the serial port address using the Terminal: ls /dev/tty.ScientISST* Copy the String like: /dev/tty.ScientISST-XX-XX-SPP_SE . You can now run the sense.py script: python sense.py /dev/tty.ScientISST-XX-XX-SPP_SE Windows Turn the ScientISST Sense board on. Now, go to Control Panel > Hardware and Sound > Devices and Printers. Select \"Add a device\". Select the ScientISST Sense board, hit \"next\" until its set up. While connected to the board, search \"Bluetooth settings\" on the Control Panel, then go to the \"COM ports\" tab and check the port name for the outgoing entry. Copy the String like: COMX You can now run the sense.py script: python sense.py COMX Examples Single Channel The following snippet will start streaming channel A1 : python sense.py -c 1 Frequency The following snippet will start streaming channel A1 at 100 Hz: python sense.py -c 1 -f 100 Multiple Channels The following snippet will start streaming channels A1 , A2 , A3 , A4 : python sense.py -c 1,2,3,4 Save to File The following snippet will start recording the default channels ( A1 , A2 , A3 , A4 , A5 , A6 ) to the file output.csv : python sense.py -o output.csv Duration The following snippet will start recording the default channels for 10 seconds : python sense.py -o output.csv -d 10 Lab Streaming Layer The following snippet will start streaming the default channels using LSL : python sense.py -s Visualize the streaming data using: Taking advantage of the LSL, it is possible to plot the real-time data: python -m pylsl.examples.ReceiveAndPlot Custom Script It is possible to run custom code every time the sense.py script reads data from the device. To do so, create a file, e.g. hello_world.py , with your own class inheriting the CustomScript class: from sense.custom_script import CustomScript class HelloWorld ( CustomScript ): def on_init ( self ): print ( \"Hello world!\" ) def on_start ( self ): print ( \"Run your custom code on start\" ) def on_read ( self , frames ): print ( \"Received %s frames\" % len ( frames )) def on_stop ( self ): print ( \"All done\" ) Then, you just have to provided its path: python sense.py -d 1 -q --script hello_world.py Output: ... Connected! Hello world! Start acquisition Run your custom code on start Received 200 frames Received 200 frames Received 200 frames Received 200 frames Received 200 frames Stop acquisition All done Disconnected","title":"sense.py"},{"location":"getting-started/sense/#usage-options","text":"$ python sense.py -h usage: sense.py [args] address description: The program connects to the ScientISST Sense device and starts an acquisition, providing the option to store the received data in a .csv file. positional arguments: address Linux: bluetooth MAC address, Mac: serial port address, Windows: bluetooth serial COM port options: -h, --help show this help message and exit -f FS, --frequency FS sampling frequency, default: 1000 -c CHANNELS, --channels CHANNELS analog channels, default: 1,2,3,4,5,6 -d DURATION, --duration DURATION duration in seconds, default: unlimited -o OUTPUT, --output OUTPUT write report to output file, default: None -r, --raw do not convert from raw to mV -s, --lsl stream data using Lab Streaming Layer protocol. Use `python -m pylsl.examples.ReceiveAndPlot` to view stream -q, --quiet don't print ScientISST frames -v, --version show sense.py version --verbose log sent/received bytes","title":"Usage Options"},{"location":"getting-started/sense/#automatic-selection","text":"Pair your device Run: python sense.py Select the device from the list displayed: ScientISST devices: [1] ScientISST-ab-de - 08:3A:F2:49:AB:DE [2] ScientISST-ac-be - 08:3A:F2:49:AC:BE Connect to: Then hit CTRL-C when you wish to stop.","title":"Automatic Selection"},{"location":"getting-started/sense/#manual-selection","text":"","title":"Manual Selection"},{"location":"getting-started/sense/#linux","text":"Pair and trust the ScientISST Sense board: bluetoothctl scan on pair XX:XX:XX:XX:XX trust XX:XX:XX:XX:XX You can now run the sense.py script: python sense.py XX:XX:XX:XX:XX","title":"Linux"},{"location":"getting-started/sense/#mac","text":"First, you need to pair the ScientISST sense device in the Bluetooth Settings section. Then, you'll need to find the serial port address using the Terminal: ls /dev/tty.ScientISST* Copy the String like: /dev/tty.ScientISST-XX-XX-SPP_SE . You can now run the sense.py script: python sense.py /dev/tty.ScientISST-XX-XX-SPP_SE","title":"Mac"},{"location":"getting-started/sense/#windows","text":"Turn the ScientISST Sense board on. Now, go to Control Panel > Hardware and Sound > Devices and Printers. Select \"Add a device\". Select the ScientISST Sense board, hit \"next\" until its set up. While connected to the board, search \"Bluetooth settings\" on the Control Panel, then go to the \"COM ports\" tab and check the port name for the outgoing entry. Copy the String like: COMX You can now run the sense.py script: python sense.py COMX","title":"Windows"},{"location":"getting-started/sense/#examples","text":"","title":"Examples"},{"location":"getting-started/sense/#single-channel","text":"The following snippet will start streaming channel A1 : python sense.py -c 1","title":"Single Channel"},{"location":"getting-started/sense/#frequency","text":"The following snippet will start streaming channel A1 at 100 Hz: python sense.py -c 1 -f 100","title":"Frequency"},{"location":"getting-started/sense/#multiple-channels","text":"The following snippet will start streaming channels A1 , A2 , A3 , A4 : python sense.py -c 1,2,3,4","title":"Multiple Channels"},{"location":"getting-started/sense/#save-to-file","text":"The following snippet will start recording the default channels ( A1 , A2 , A3 , A4 , A5 , A6 ) to the file output.csv : python sense.py -o output.csv","title":"Save to File"},{"location":"getting-started/sense/#duration","text":"The following snippet will start recording the default channels for 10 seconds : python sense.py -o output.csv -d 10","title":"Duration"},{"location":"getting-started/sense/#lab-streaming-layer","text":"The following snippet will start streaming the default channels using LSL : python sense.py -s","title":"Lab Streaming Layer"},{"location":"getting-started/sense/#visualize-the-streaming-data-using","text":"Taking advantage of the LSL, it is possible to plot the real-time data: python -m pylsl.examples.ReceiveAndPlot","title":"Visualize the streaming data using:"},{"location":"getting-started/sense/#custom-script","text":"It is possible to run custom code every time the sense.py script reads data from the device. To do so, create a file, e.g. hello_world.py , with your own class inheriting the CustomScript class: from sense.custom_script import CustomScript class HelloWorld ( CustomScript ): def on_init ( self ): print ( \"Hello world!\" ) def on_start ( self ): print ( \"Run your custom code on start\" ) def on_read ( self , frames ): print ( \"Received %s frames\" % len ( frames )) def on_stop ( self ): print ( \"All done\" ) Then, you just have to provided its path: python sense.py -d 1 -q --script hello_world.py Output: ... Connected! Hello world! Start acquisition Run your custom code on start Received 200 frames Received 200 frames Received 200 frames Received 200 frames Received 200 frames Stop acquisition All done Disconnected","title":"Custom Script"},{"location":"reference/exceptions-reference/","text":"BTAdapterNotFoundError Bases: Exception No Bluetooth adapter was found. Source code in scientisst/exceptions.py 10 11 12 13 14 15 16 class BTAdapterNotFoundError ( Exception ): \"\"\" No Bluetooth adapter was found. \"\"\" def __init__ ( self ): super () . __init__ ( \"No Bluetooth adapter was found.\" ) ContactingDeviceError Bases: Exception The computer lost communication with the device. Source code in scientisst/exceptions.py 28 29 30 31 32 33 34 class ContactingDeviceError ( Exception ): \"\"\" The computer lost communication with the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"The computer lost communication with the device.\" ) DeviceNotFoundError Bases: Exception The device could not be found. Source code in scientisst/exceptions.py 19 20 21 22 23 24 25 class DeviceNotFoundError ( Exception ): \"\"\" The device could not be found. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device could not be found.\" ) DeviceNotIdleError Bases: Exception The device is not idle. Source code in scientisst/exceptions.py 57 58 59 60 61 62 63 class DeviceNotIdleError ( Exception ): \"\"\" The device is not idle. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not idle.\" ) DeviceNotInAcquisitionError Bases: Exception The device is not in acquisition mode. Source code in scientisst/exceptions.py 66 67 68 69 70 71 72 class DeviceNotInAcquisitionError ( Exception ): \"\"\" The device is not in acquisition mode. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not in acquisition mode.\" ) InvalidAddressError Bases: Exception The specified address is invalid. Source code in scientisst/exceptions.py 1 2 3 4 5 6 7 class InvalidAddressError ( Exception ): \"\"\" The specified address is invalid. \"\"\" def __init__ ( self ): super () . __init__ ( \"The specified address is invalid.\" ) InvalidParameterError Bases: Exception Invalid parameter. Source code in scientisst/exceptions.py 75 76 77 78 79 80 81 class InvalidParameterError ( Exception ): \"\"\" Invalid parameter. \"\"\" def __init__ ( self ): super () . __init__ ( \"Invalid parameter.\" ) NotSupportedError Bases: Exception Operation not supported by the device. Source code in scientisst/exceptions.py 84 85 86 87 88 89 90 class NotSupportedError ( Exception ): \"\"\" Operation not supported by the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"Operation not supported by the device.\" ) PortCouldNotBeOpenedError Bases: Exception The communication port does not exist or it is already being used. Source code in scientisst/exceptions.py 37 38 39 40 41 42 43 44 45 class PortCouldNotBeOpenedError ( Exception ): \"\"\" The communication port does not exist or it is already being used. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port does not exist or it is already being used.\" ) PortInitializationError Bases: Exception The communication port could not be initialized. Source code in scientisst/exceptions.py 48 49 50 51 52 53 54 class PortInitializationError ( Exception ): \"\"\" The communication port could not be initialized. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port could not be initialized.\" ) UnknownError Bases: Exception Unknown error: message . Source code in scientisst/exceptions.py 93 94 95 96 97 98 99 class UnknownError ( Exception ): \"\"\" Unknown error: `message`. \"\"\" def __init__ ( self , message = \"\" ): super () . __init__ ( \"Unknown error: {} \" . format ( message ))","title":"Exceptions"},{"location":"reference/exceptions-reference/#scientisst.exceptions.BTAdapterNotFoundError","text":"Bases: Exception No Bluetooth adapter was found. Source code in scientisst/exceptions.py 10 11 12 13 14 15 16 class BTAdapterNotFoundError ( Exception ): \"\"\" No Bluetooth adapter was found. \"\"\" def __init__ ( self ): super () . __init__ ( \"No Bluetooth adapter was found.\" )","title":"BTAdapterNotFoundError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.ContactingDeviceError","text":"Bases: Exception The computer lost communication with the device. Source code in scientisst/exceptions.py 28 29 30 31 32 33 34 class ContactingDeviceError ( Exception ): \"\"\" The computer lost communication with the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"The computer lost communication with the device.\" )","title":"ContactingDeviceError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotFoundError","text":"Bases: Exception The device could not be found. Source code in scientisst/exceptions.py 19 20 21 22 23 24 25 class DeviceNotFoundError ( Exception ): \"\"\" The device could not be found. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device could not be found.\" )","title":"DeviceNotFoundError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotIdleError","text":"Bases: Exception The device is not idle. Source code in scientisst/exceptions.py 57 58 59 60 61 62 63 class DeviceNotIdleError ( Exception ): \"\"\" The device is not idle. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not idle.\" )","title":"DeviceNotIdleError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotInAcquisitionError","text":"Bases: Exception The device is not in acquisition mode. Source code in scientisst/exceptions.py 66 67 68 69 70 71 72 class DeviceNotInAcquisitionError ( Exception ): \"\"\" The device is not in acquisition mode. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not in acquisition mode.\" )","title":"DeviceNotInAcquisitionError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.InvalidAddressError","text":"Bases: Exception The specified address is invalid. Source code in scientisst/exceptions.py 1 2 3 4 5 6 7 class InvalidAddressError ( Exception ): \"\"\" The specified address is invalid. \"\"\" def __init__ ( self ): super () . __init__ ( \"The specified address is invalid.\" )","title":"InvalidAddressError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.InvalidParameterError","text":"Bases: Exception Invalid parameter. Source code in scientisst/exceptions.py 75 76 77 78 79 80 81 class InvalidParameterError ( Exception ): \"\"\" Invalid parameter. \"\"\" def __init__ ( self ): super () . __init__ ( \"Invalid parameter.\" )","title":"InvalidParameterError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.NotSupportedError","text":"Bases: Exception Operation not supported by the device. Source code in scientisst/exceptions.py 84 85 86 87 88 89 90 class NotSupportedError ( Exception ): \"\"\" Operation not supported by the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"Operation not supported by the device.\" )","title":"NotSupportedError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.PortCouldNotBeOpenedError","text":"Bases: Exception The communication port does not exist or it is already being used. Source code in scientisst/exceptions.py 37 38 39 40 41 42 43 44 45 class PortCouldNotBeOpenedError ( Exception ): \"\"\" The communication port does not exist or it is already being used. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port does not exist or it is already being used.\" )","title":"PortCouldNotBeOpenedError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.PortInitializationError","text":"Bases: Exception The communication port could not be initialized. Source code in scientisst/exceptions.py 48 49 50 51 52 53 54 class PortInitializationError ( Exception ): \"\"\" The communication port could not be initialized. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port could not be initialized.\" )","title":"PortInitializationError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.UnknownError","text":"Bases: Exception Unknown error: message . Source code in scientisst/exceptions.py 93 94 95 96 97 98 99 class UnknownError ( Exception ): \"\"\" Unknown error: `message`. \"\"\" def __init__ ( self , message = \"\" ): super () . __init__ ( \"Unknown error: {} \" . format ( message ))","title":"UnknownError"},{"location":"reference/frame-reference/","text":"Frame ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: Name Type Description seq int Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital list Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a list Array of raw analog inputs values of the active channles. If all channels are active, a will have 8 elements: 6 AIs and 2 AXs. mv list Array of analog inputs values of the active channles in mV. If all channels are active, mv will have 8 elements: 6 AIs and 2 AXs. Source code in scientisst/frame.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Frame : \"\"\" ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: seq (int): Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital (list): Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a (list): Array of raw analog inputs values of the active channles. If all channels are active, `a` will have 8 elements: 6 AIs and 2 AXs. mv (list): Array of analog inputs values of the active channles in mV. If all channels are active, `mv` will have 8 elements: 6 AIs and 2 AXs. \"\"\" digital = [ 0 ] * 4 seq = - 1 a = None mv = None def __init__ ( self , num_channels ): self . a = [ None ] * num_channels self . mv = [ None ] * num_channels def to_map ( self ): return { \"sequence\" : self . seq , \"analog\" : self . a , \"digital\" : self . digital , \"mv\" : self . mv , } def to_string ( self ): return str ( self . toMap ()) def __str__ ( self ): if self . mv [ 0 ]: values = [ str ( val ) for pair in zip ( self . a , self . mv ) for val in pair ] else : values = map ( str , self . a ) return \" {} \\t {} \\t {} \\t {} \\t {} \\t {} \" . format ( self . seq , self . digital [ 0 ], self . digital [ 1 ], self . digital [ 2 ], self . digital [ 3 ], \" \\t \" . join ( values ), ) def to_matrix ( self ): if self . mv [ 0 ]: return ( [ self . seq ] + self . digital + [ val for pair in zip ( self . a , self . mv ) for val in pair ] ) else : return [ self . seq ] + self . digital + self . a","title":"Frame"},{"location":"reference/frame-reference/#scientisst.frame.Frame","text":"ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: Name Type Description seq int Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital list Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a list Array of raw analog inputs values of the active channles. If all channels are active, a will have 8 elements: 6 AIs and 2 AXs. mv list Array of analog inputs values of the active channles in mV. If all channels are active, mv will have 8 elements: 6 AIs and 2 AXs. Source code in scientisst/frame.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Frame : \"\"\" ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: seq (int): Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital (list): Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a (list): Array of raw analog inputs values of the active channles. If all channels are active, `a` will have 8 elements: 6 AIs and 2 AXs. mv (list): Array of analog inputs values of the active channles in mV. If all channels are active, `mv` will have 8 elements: 6 AIs and 2 AXs. \"\"\" digital = [ 0 ] * 4 seq = - 1 a = None mv = None def __init__ ( self , num_channels ): self . a = [ None ] * num_channels self . mv = [ None ] * num_channels def to_map ( self ): return { \"sequence\" : self . seq , \"analog\" : self . a , \"digital\" : self . digital , \"mv\" : self . mv , } def to_string ( self ): return str ( self . toMap ()) def __str__ ( self ): if self . mv [ 0 ]: values = [ str ( val ) for pair in zip ( self . a , self . mv ) for val in pair ] else : values = map ( str , self . a ) return \" {} \\t {} \\t {} \\t {} \\t {} \\t {} \" . format ( self . seq , self . digital [ 0 ], self . digital [ 1 ], self . digital [ 2 ], self . digital [ 3 ], \" \\t \" . join ( values ), ) def to_matrix ( self ): if self . mv [ 0 ]: return ( [ self . seq ] + self . digital + [ val for pair in zip ( self . a , self . mv ) for val in pair ] ) else : return [ self . seq ] + self . digital + self . a","title":"Frame"},{"location":"reference/scientisst-reference/","text":"ScientISST ScientISST Device class Attributes: Name Type Description address str The device serial port address (\"/dev/example\") serial_speed int The serial port bitrate. Source code in scientisst/scientisst.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class ScientISST : \"\"\"ScientISST Device class Attributes: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate. \"\"\" __serial = None __socket = None __num_chs = 0 __api_mode = 1 __sample_rate = None __chs = [ None ] * 8 __log = False def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST , connection_tries = 5 , ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # try to connect to board while True : try : # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () break except ContactingDeviceError : if connection_tries > 0 : connection_tries -= 1 else : raise ContactingDeviceError () sys . stdout . write ( \"Connected! \\n \" ) def version_and_adc_chars ( self , print = True ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) self . __adc1_chars = EspAdcCalChars ( result [ index + 1 :]) if print : sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( self . __adc1_chars . vref ) ) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( self . __adc1_chars . atten ) ) return version def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size def read ( self , convert = True , matrix = False ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV matrix (bool): Return `Frames` in a `np.array` (matrix) form Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device. If `matrix` is True, the `frames` corresponds to a `np.array` (matrix). Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = self . __adc1_chars . esp_adc_cal_raw_to_voltage ( f . a [ index ] ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : if not matrix : return frames else : return np . array ([ frame . to_matrix () for frame in frames ]) else : raise ContactingDeviceError () def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear () def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd ) def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd ) def dac ( self , voltage ): \"\"\" Assigns the analog (DAC) output value (ScientISST 2 only). Args: voltage (float): Analog output value to set (0V-3.3V). Raises: InvalidParameterError: If the voltage value is outside of its range, 0-255. \"\"\" if voltage < 0 or voltage > 3.3 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output #Convert from voltage to raw: raw = int ( voltage * 255 / 3.3 ) cmd |= raw << 8 self . __send ( cmd , nrOfBytes = 2 ) # TODO: test with ScientISST Sense v2 def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result ) # for(int i = 0; i < 6; i++) # state.analog[i] = statex.analog[i]; # state.battery = statex.battery; # state.batThreshold = statex.batThreshold; # for(int i = 0; i < 4; i++) # state.digital[i] = ((statex.portsCRC & (0x80 >> i)) != 0); # return state; def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" ) def __getPacketSize ( self ): packet_size = 0 if self . __api_mode == API_MODE_SCIENTISST : num_intern_active_chs = 0 num_extern_active_chs = 0 for ch in self . __chs : if ch : # Add 24bit channel's contributuion to packet size if ch == AX1 or ch == AX2 : num_extern_active_chs += 1 # Count 12bit channels else : num_intern_active_chs += 1 # Add 24bit channel's contributuion to packet size packet_size = 3 * num_extern_active_chs # Add 12bit channel's contributuion to packet size if not ( num_intern_active_chs % 2 ): # If it's an even number packet_size += ( num_intern_active_chs * 12 ) / 8 else : packet_size += ( ( num_intern_active_chs * 12 ) - 4 ) / 8 # -4 because 4 bits can go in the I/0 byte # for the I/Os and seq+crc bytes packet_size += 2 elif self . __api_mode == API_MODE_JSON : for i in range ( self . __num_chs ): # If it's internal ch if self . __chs [ i ] <= 6 : # sprintf(aux_str, \"AI%d\", chs[i]); # member_name.SetString(aux_str, d.GetAllocator()); # member_value.SetString(value_internal_str, d.GetAllocator()); # d.AddMember(member_name, member_value, d.GetAllocator()); packet_size += 3 # AI%d packet_size += 2 # 0-4095 = 12 bits <= 2 bytes else : packet_size += 3 # AX%d packet_size += 4 # 0-16777215 = 24 bits <= 4 bytes # Add IO state json objects # d.AddMember(\"I1\", \"0\", d.GetAllocator()); # d.AddMember(\"I2\", \"0\", d.GetAllocator()); # d.AddMember(\"O1\", \"0\", d.GetAllocator()); # d.AddMember(\"O2\", \"0\", d.GetAllocator()); packet_size += 3 # I1 + 0|1 packet_size += 3 # I2 + 0|1 packet_size += 3 # O1 + 0|1 packet_size += 3 # O1 + 0|1 else : raise NotSupportedError () return int ( packet_size ) def __changeAPI ( self , api ): if self . __num_chs and self . __num_chs != 0 : raise DeviceNotIdleError () if api <= 0 or api > 3 : raise InvalidParameterError () self . __api_mode = api api <<= 4 api |= 0b11 self . __send ( api ) def __checkCRC4 ( self , data , length ): CRC4tab = [ 0 , 3 , 6 , 5 , 12 , 15 , 10 , 9 , 11 , 8 , 13 , 14 , 7 , 4 , 1 , 2 ] crc = 0 for i in range ( length - 1 ): b = data [ i ] crc = CRC4tab [ crc ] ^ ( b >> 4 ) crc = CRC4tab [ crc ] ^ ( b & 0x0F ) # CRC for last byte crc = CRC4tab [ crc ] ^ ( data [ - 1 ] >> 4 ) crc = CRC4tab [ crc ] return crc == ( data [ - 1 ] & 0x0F ) def __send ( self , command , nrOfBytes = None ): \"\"\" Send data \"\"\" if type ( command ) is int : if command != 0 : command = command . to_bytes ( int ( log2 ( command ) // 8 + 1 ), byteorder = \"little\" ) else : command = b \" \\x00 \" if nrOfBytes and len ( command ) < nrOfBytes : for _ in range ( nrOfBytes - len ( command )): command += b \" \\x00 \" # if self.__serial: time . sleep ( 0.250 ) if self . __log : sys . stdout . write ( \" {} bytes sent: {} \\n \" . format ( len ( command ), \" \" . join ( \" {:02x} \" . format ( c ) for c in command ) ) ) if self . __socket : self . __socket . send ( command ) else : self . __serial . write ( command ) # else: # raise ContactingDeviceError() def __recv ( self , nrOfBytes ): \"\"\" Receive data \"\"\" result = None if self . __socket : result = self . __socket . recv ( nrOfBytes , socket . MSG_WAITALL ) else : result = self . __serial . read ( nrOfBytes ) if self . __log : if nrOfBytes > 1 : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( nrOfBytes , \" \" . join ( \" {:02x} \" . format ( c ) for c in result ) ) ) else : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( 1 , result . hex ())) return result def __clear ( self ): \"\"\" Clear the device buffer \"\"\" if self . __socket : self . __socket . setblocking ( False ) else : self . __serial . timeout = 0 try : while self . __recv ( 1 ): pass except BlockingIOError : pass if self . __socket : self . __socket . setblocking ( True ) else : self . __serial . timeout = TIMEOUT_IN_SECONDS __clear () Clear the device buffer Source code in scientisst/scientisst.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 def __clear ( self ): \"\"\" Clear the device buffer \"\"\" if self . __socket : self . __socket . setblocking ( False ) else : self . __serial . timeout = 0 try : while self . __recv ( 1 ): pass except BlockingIOError : pass if self . __socket : self . __socket . setblocking ( True ) else : self . __serial . timeout = TIMEOUT_IN_SECONDS __init__ ( address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST , connection_tries = 5 ) Parameters: Name Type Description Default address str The device serial port address (\"/dev/example\") required serial_speed int The serial port bitrate in bit/s 115200 log bool If the bytes sent and received should be showed False api int The desired API mode for the device API_MODE_SCIENTISST Source code in scientisst/scientisst.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST , connection_tries = 5 , ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # try to connect to board while True : try : # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () break except ContactingDeviceError : if connection_tries > 0 : connection_tries -= 1 else : raise ContactingDeviceError () sys . stdout . write ( \"Connected! \\n \" ) __recv ( nrOfBytes ) Receive data Source code in scientisst/scientisst.py 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 def __recv ( self , nrOfBytes ): \"\"\" Receive data \"\"\" result = None if self . __socket : result = self . __socket . recv ( nrOfBytes , socket . MSG_WAITALL ) else : result = self . __serial . read ( nrOfBytes ) if self . __log : if nrOfBytes > 1 : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( nrOfBytes , \" \" . join ( \" {:02x} \" . format ( c ) for c in result ) ) ) else : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( 1 , result . hex ())) return result __send ( command , nrOfBytes = None ) Send data Source code in scientisst/scientisst.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 def __send ( self , command , nrOfBytes = None ): \"\"\" Send data \"\"\" if type ( command ) is int : if command != 0 : command = command . to_bytes ( int ( log2 ( command ) // 8 + 1 ), byteorder = \"little\" ) else : command = b \" \\x00 \" if nrOfBytes and len ( command ) < nrOfBytes : for _ in range ( nrOfBytes - len ( command )): command += b \" \\x00 \" # if self.__serial: time . sleep ( 0.250 ) if self . __log : sys . stdout . write ( \" {} bytes sent: {} \\n \" . format ( len ( command ), \" \" . join ( \" {:02x} \" . format ( c ) for c in command ) ) ) if self . __socket : self . __socket . send ( command ) else : self . __serial . write ( command ) battery ( value = 0 ) Sets the battery voltage threshold for the low-battery LED. Parameters: Name Type Description Default value int Battery voltage threshold. Default value is 0. Value Voltage Threshold 0 3.4 V ... ... 63 3.8 V 0 Raises: Type Description DeviceNotIdleError If the device is in acquisition mode. InvalidParameterError If an invalid battery threshold value is given. Source code in scientisst/scientisst.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd ) dac ( voltage ) Assigns the analog (DAC) output value (ScientISST 2 only). Parameters: Name Type Description Default voltage float Analog output value to set (0V-3.3V). required Raises: Type Description InvalidParameterError If the voltage value is outside of its range, 0-255. Source code in scientisst/scientisst.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def dac ( self , voltage ): \"\"\" Assigns the analog (DAC) output value (ScientISST 2 only). Args: voltage (float): Analog output value to set (0V-3.3V). Raises: InvalidParameterError: If the voltage value is outside of its range, 0-255. \"\"\" if voltage < 0 or voltage > 3.3 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output #Convert from voltage to raw: raw = int ( voltage * 255 / 3.3 ) cmd |= raw << 8 self . __send ( cmd , nrOfBytes = 2 ) disconnect () Disconnects from a ScientISST device. If an aquisition is running, it is stopped Source code in scientisst/scientisst.py 487 488 489 490 491 492 493 494 495 496 497 498 499 def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" ) read ( convert = True , matrix = False ) Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Parameters: Name Type Description Default convert bool Convert from raw to mV True matrix bool Return Frames in a np.array (matrix) form False Returns: Name Type Description frames list List of Frame objects retrieved from the device. If matrix is True, the frames corresponds to a np.array (matrix). Raises: Type Description ContactingDeviceError If there is an error contacting the device. DeviceNotInAcquisitionError If the device is not in acquisition mode. NotSupportedError If the device API is in BITALINO mode UnknownError If the device stopped sending frames for some unknown reason. Source code in scientisst/scientisst.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def read ( self , convert = True , matrix = False ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV matrix (bool): Return `Frames` in a `np.array` (matrix) form Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device. If `matrix` is True, the `frames` corresponds to a `np.array` (matrix). Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = self . __adc1_chars . esp_adc_cal_raw_to_voltage ( f . a [ index ] ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : if not matrix : return frames else : return np . array ([ frame . to_matrix () for frame in frames ]) else : raise ContactingDeviceError () start ( sample_rate , channels , reads_per_second = 5 , simulated = False ) Starts a signal acquisition from the device Parameters: Name Type Description Default sample_rate int Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. required channels list Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. required reads_per_second int Number of times to read the data streaming from the device. Accepted values are integers greater than 0. 5 simulated bool If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. False Raises: Type Description DeviceNotIdleError If the device is already in acquisition mode. InvalidParameterError If no valid API value is chosen or an incorrect array of channels is provided. Source code in scientisst/scientisst.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size state () Returns current device state (%ScientISST 2 only). Returns: Name Type Description state State Current device State Raises: Type Description DeviceNotIdleError If the device is in acquisition mode. ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result ) stop () Stops a signal acquisition. Raises: Type Description DeviceNotInAcquisitionError If the device is not in acquisition mode. Source code in scientisst/scientisst.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear () trigger ( digital_output ) Assigns the digital outputs states. Parameters: Name Type Description Default digital_output list Vector of booleans to assign to digital outputs, starting at first output (O1). required Raises: Type Description InvalidParameterError If the length of the digital_output array is different from 2. Source code in scientisst/scientisst.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd ) version_and_adc_chars ( print = True ) Gets the device firmware version string and esp_adc_characteristics Returns: Name Type Description version str Firmware version Raises: Type Description ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def version_and_adc_chars ( self , print = True ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) self . __adc1_chars = EspAdcCalChars ( result [ index + 1 :]) if print : sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( self . __adc1_chars . vref ) ) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( self . __adc1_chars . atten ) ) return version","title":"ScientISST"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST","text":"ScientISST Device class Attributes: Name Type Description address str The device serial port address (\"/dev/example\") serial_speed int The serial port bitrate. Source code in scientisst/scientisst.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class ScientISST : \"\"\"ScientISST Device class Attributes: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate. \"\"\" __serial = None __socket = None __num_chs = 0 __api_mode = 1 __sample_rate = None __chs = [ None ] * 8 __log = False def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST , connection_tries = 5 , ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # try to connect to board while True : try : # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () break except ContactingDeviceError : if connection_tries > 0 : connection_tries -= 1 else : raise ContactingDeviceError () sys . stdout . write ( \"Connected! \\n \" ) def version_and_adc_chars ( self , print = True ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) self . __adc1_chars = EspAdcCalChars ( result [ index + 1 :]) if print : sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( self . __adc1_chars . vref ) ) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( self . __adc1_chars . atten ) ) return version def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size def read ( self , convert = True , matrix = False ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV matrix (bool): Return `Frames` in a `np.array` (matrix) form Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device. If `matrix` is True, the `frames` corresponds to a `np.array` (matrix). Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = self . __adc1_chars . esp_adc_cal_raw_to_voltage ( f . a [ index ] ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : if not matrix : return frames else : return np . array ([ frame . to_matrix () for frame in frames ]) else : raise ContactingDeviceError () def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear () def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd ) def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd ) def dac ( self , voltage ): \"\"\" Assigns the analog (DAC) output value (ScientISST 2 only). Args: voltage (float): Analog output value to set (0V-3.3V). Raises: InvalidParameterError: If the voltage value is outside of its range, 0-255. \"\"\" if voltage < 0 or voltage > 3.3 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output #Convert from voltage to raw: raw = int ( voltage * 255 / 3.3 ) cmd |= raw << 8 self . __send ( cmd , nrOfBytes = 2 ) # TODO: test with ScientISST Sense v2 def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result ) # for(int i = 0; i < 6; i++) # state.analog[i] = statex.analog[i]; # state.battery = statex.battery; # state.batThreshold = statex.batThreshold; # for(int i = 0; i < 4; i++) # state.digital[i] = ((statex.portsCRC & (0x80 >> i)) != 0); # return state; def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" ) def __getPacketSize ( self ): packet_size = 0 if self . __api_mode == API_MODE_SCIENTISST : num_intern_active_chs = 0 num_extern_active_chs = 0 for ch in self . __chs : if ch : # Add 24bit channel's contributuion to packet size if ch == AX1 or ch == AX2 : num_extern_active_chs += 1 # Count 12bit channels else : num_intern_active_chs += 1 # Add 24bit channel's contributuion to packet size packet_size = 3 * num_extern_active_chs # Add 12bit channel's contributuion to packet size if not ( num_intern_active_chs % 2 ): # If it's an even number packet_size += ( num_intern_active_chs * 12 ) / 8 else : packet_size += ( ( num_intern_active_chs * 12 ) - 4 ) / 8 # -4 because 4 bits can go in the I/0 byte # for the I/Os and seq+crc bytes packet_size += 2 elif self . __api_mode == API_MODE_JSON : for i in range ( self . __num_chs ): # If it's internal ch if self . __chs [ i ] <= 6 : # sprintf(aux_str, \"AI%d\", chs[i]); # member_name.SetString(aux_str, d.GetAllocator()); # member_value.SetString(value_internal_str, d.GetAllocator()); # d.AddMember(member_name, member_value, d.GetAllocator()); packet_size += 3 # AI%d packet_size += 2 # 0-4095 = 12 bits <= 2 bytes else : packet_size += 3 # AX%d packet_size += 4 # 0-16777215 = 24 bits <= 4 bytes # Add IO state json objects # d.AddMember(\"I1\", \"0\", d.GetAllocator()); # d.AddMember(\"I2\", \"0\", d.GetAllocator()); # d.AddMember(\"O1\", \"0\", d.GetAllocator()); # d.AddMember(\"O2\", \"0\", d.GetAllocator()); packet_size += 3 # I1 + 0|1 packet_size += 3 # I2 + 0|1 packet_size += 3 # O1 + 0|1 packet_size += 3 # O1 + 0|1 else : raise NotSupportedError () return int ( packet_size ) def __changeAPI ( self , api ): if self . __num_chs and self . __num_chs != 0 : raise DeviceNotIdleError () if api <= 0 or api > 3 : raise InvalidParameterError () self . __api_mode = api api <<= 4 api |= 0b11 self . __send ( api ) def __checkCRC4 ( self , data , length ): CRC4tab = [ 0 , 3 , 6 , 5 , 12 , 15 , 10 , 9 , 11 , 8 , 13 , 14 , 7 , 4 , 1 , 2 ] crc = 0 for i in range ( length - 1 ): b = data [ i ] crc = CRC4tab [ crc ] ^ ( b >> 4 ) crc = CRC4tab [ crc ] ^ ( b & 0x0F ) # CRC for last byte crc = CRC4tab [ crc ] ^ ( data [ - 1 ] >> 4 ) crc = CRC4tab [ crc ] return crc == ( data [ - 1 ] & 0x0F ) def __send ( self , command , nrOfBytes = None ): \"\"\" Send data \"\"\" if type ( command ) is int : if command != 0 : command = command . to_bytes ( int ( log2 ( command ) // 8 + 1 ), byteorder = \"little\" ) else : command = b \" \\x00 \" if nrOfBytes and len ( command ) < nrOfBytes : for _ in range ( nrOfBytes - len ( command )): command += b \" \\x00 \" # if self.__serial: time . sleep ( 0.250 ) if self . __log : sys . stdout . write ( \" {} bytes sent: {} \\n \" . format ( len ( command ), \" \" . join ( \" {:02x} \" . format ( c ) for c in command ) ) ) if self . __socket : self . __socket . send ( command ) else : self . __serial . write ( command ) # else: # raise ContactingDeviceError() def __recv ( self , nrOfBytes ): \"\"\" Receive data \"\"\" result = None if self . __socket : result = self . __socket . recv ( nrOfBytes , socket . MSG_WAITALL ) else : result = self . __serial . read ( nrOfBytes ) if self . __log : if nrOfBytes > 1 : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( nrOfBytes , \" \" . join ( \" {:02x} \" . format ( c ) for c in result ) ) ) else : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( 1 , result . hex ())) return result def __clear ( self ): \"\"\" Clear the device buffer \"\"\" if self . __socket : self . __socket . setblocking ( False ) else : self . __serial . timeout = 0 try : while self . __recv ( 1 ): pass except BlockingIOError : pass if self . __socket : self . __socket . setblocking ( True ) else : self . __serial . timeout = TIMEOUT_IN_SECONDS","title":"ScientISST"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__clear","text":"Clear the device buffer Source code in scientisst/scientisst.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 def __clear ( self ): \"\"\" Clear the device buffer \"\"\" if self . __socket : self . __socket . setblocking ( False ) else : self . __serial . timeout = 0 try : while self . __recv ( 1 ): pass except BlockingIOError : pass if self . __socket : self . __socket . setblocking ( True ) else : self . __serial . timeout = TIMEOUT_IN_SECONDS","title":"__clear()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__init__","text":"Parameters: Name Type Description Default address str The device serial port address (\"/dev/example\") required serial_speed int The serial port bitrate in bit/s 115200 log bool If the bytes sent and received should be showed False api int The desired API mode for the device API_MODE_SCIENTISST Source code in scientisst/scientisst.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST , connection_tries = 5 , ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # try to connect to board while True : try : # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () break except ContactingDeviceError : if connection_tries > 0 : connection_tries -= 1 else : raise ContactingDeviceError () sys . stdout . write ( \"Connected! \\n \" )","title":"__init__()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__recv","text":"Receive data Source code in scientisst/scientisst.py 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 def __recv ( self , nrOfBytes ): \"\"\" Receive data \"\"\" result = None if self . __socket : result = self . __socket . recv ( nrOfBytes , socket . MSG_WAITALL ) else : result = self . __serial . read ( nrOfBytes ) if self . __log : if nrOfBytes > 1 : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( nrOfBytes , \" \" . join ( \" {:02x} \" . format ( c ) for c in result ) ) ) else : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( 1 , result . hex ())) return result","title":"__recv()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__send","text":"Send data Source code in scientisst/scientisst.py 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 def __send ( self , command , nrOfBytes = None ): \"\"\" Send data \"\"\" if type ( command ) is int : if command != 0 : command = command . to_bytes ( int ( log2 ( command ) // 8 + 1 ), byteorder = \"little\" ) else : command = b \" \\x00 \" if nrOfBytes and len ( command ) < nrOfBytes : for _ in range ( nrOfBytes - len ( command )): command += b \" \\x00 \" # if self.__serial: time . sleep ( 0.250 ) if self . __log : sys . stdout . write ( \" {} bytes sent: {} \\n \" . format ( len ( command ), \" \" . join ( \" {:02x} \" . format ( c ) for c in command ) ) ) if self . __socket : self . __socket . send ( command ) else : self . __serial . write ( command )","title":"__send()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.battery","text":"Sets the battery voltage threshold for the low-battery LED. Parameters: Name Type Description Default value int Battery voltage threshold. Default value is 0. Value Voltage Threshold 0 3.4 V ... ... 63 3.8 V 0 Raises: Type Description DeviceNotIdleError If the device is in acquisition mode. InvalidParameterError If an invalid battery threshold value is given. Source code in scientisst/scientisst.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd )","title":"battery()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.dac","text":"Assigns the analog (DAC) output value (ScientISST 2 only). Parameters: Name Type Description Default voltage float Analog output value to set (0V-3.3V). required Raises: Type Description InvalidParameterError If the voltage value is outside of its range, 0-255. Source code in scientisst/scientisst.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 def dac ( self , voltage ): \"\"\" Assigns the analog (DAC) output value (ScientISST 2 only). Args: voltage (float): Analog output value to set (0V-3.3V). Raises: InvalidParameterError: If the voltage value is outside of its range, 0-255. \"\"\" if voltage < 0 or voltage > 3.3 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output #Convert from voltage to raw: raw = int ( voltage * 255 / 3.3 ) cmd |= raw << 8 self . __send ( cmd , nrOfBytes = 2 )","title":"dac()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.disconnect","text":"Disconnects from a ScientISST device. If an aquisition is running, it is stopped Source code in scientisst/scientisst.py 487 488 489 490 491 492 493 494 495 496 497 498 499 def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" )","title":"disconnect()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.read","text":"Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Parameters: Name Type Description Default convert bool Convert from raw to mV True matrix bool Return Frames in a np.array (matrix) form False Returns: Name Type Description frames list List of Frame objects retrieved from the device. If matrix is True, the frames corresponds to a np.array (matrix). Raises: Type Description ContactingDeviceError If there is an error contacting the device. DeviceNotInAcquisitionError If the device is not in acquisition mode. NotSupportedError If the device API is in BITALINO mode UnknownError If the device stopped sending frames for some unknown reason. Source code in scientisst/scientisst.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def read ( self , convert = True , matrix = False ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV matrix (bool): Return `Frames` in a `np.array` (matrix) form Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device. If `matrix` is True, the `frames` corresponds to a `np.array` (matrix). Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = self . __adc1_chars . esp_adc_cal_raw_to_voltage ( f . a [ index ] ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : if not matrix : return frames else : return np . array ([ frame . to_matrix () for frame in frames ]) else : raise ContactingDeviceError ()","title":"read()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.start","text":"Starts a signal acquisition from the device Parameters: Name Type Description Default sample_rate int Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. required channels list Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. required reads_per_second int Number of times to read the data streaming from the device. Accepted values are integers greater than 0. 5 simulated bool If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. False Raises: Type Description DeviceNotIdleError If the device is already in acquisition mode. InvalidParameterError If no valid API value is chosen or an incorrect array of channels is provided. Source code in scientisst/scientisst.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size","title":"start()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.state","text":"Returns current device state (%ScientISST 2 only). Returns: Name Type Description state State Current device State Raises: Type Description DeviceNotIdleError If the device is in acquisition mode. ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result )","title":"state()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.stop","text":"Stops a signal acquisition. Raises: Type Description DeviceNotInAcquisitionError If the device is not in acquisition mode. Source code in scientisst/scientisst.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear ()","title":"stop()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.trigger","text":"Assigns the digital outputs states. Parameters: Name Type Description Default digital_output list Vector of booleans to assign to digital outputs, starting at first output (O1). required Raises: Type Description InvalidParameterError If the length of the digital_output array is different from 2. Source code in scientisst/scientisst.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd )","title":"trigger()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.version_and_adc_chars","text":"Gets the device firmware version string and esp_adc_characteristics Returns: Name Type Description version str Firmware version Raises: Type Description ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def version_and_adc_chars ( self , print = True ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) self . __adc1_chars = EspAdcCalChars ( result [ index + 1 :]) if print : sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( self . __adc1_chars . vref ) ) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( self . __adc1_chars . atten ) ) return version","title":"version_and_adc_chars()"},{"location":"reference/state-reference/","text":"State ScientISST Device State class A state returned by ScientISST.state() Source code in scientisst/state.py 1 2 3 4 5 6 7 8 9 10 11 12 class State : \"\"\" ScientISST Device State class A state returned by ScientISST.state() \"\"\" a = [ 0 ] * 8 digital = [ 0 ] * 4 battery = None bat_threshold = None","title":"State"},{"location":"reference/state-reference/#scientisst.state.State","text":"ScientISST Device State class A state returned by ScientISST.state() Source code in scientisst/state.py 1 2 3 4 5 6 7 8 9 10 11 12 class State : \"\"\" ScientISST Device State class A state returned by ScientISST.state() \"\"\" a = [ 0 ] * 8 digital = [ 0 ] * 4 battery = None bat_threshold = None","title":"State"}]}