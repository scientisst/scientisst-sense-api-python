{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"scientisst-sense-api-python","text":"<p>The ScientISST SENSE Python API.</p> <p>Here you can find everything about this Python API:</p> <ul> <li>Installation</li> <li>Getting Started</li> <li>Reference</li> </ul> <p> </p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#pip","title":"Pip","text":"<p>Simply install it via <code>pip</code>:</p> <pre><code>pip install scientisst-sense\n</code></pre>"},{"location":"installation/#clone-the-repo","title":"Clone the Repo","text":"<pre><code># Getting this repository\ngit clone https://github.com/scientisst/scientisst-sense-api-python.git\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>API:</p> <ul> <li>PySerial</li> </ul> <p>Sense:</p> <ul> <li>pylsl</li> <li>pydbus</li> </ul> <p>Plot:</p> <ul> <li>numpy</li> <li>matplotlib</li> </ul> <p>Install them using <code>pip</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Start having fun!</p>"},{"location":"getting-started/api/","title":"API","text":""},{"location":"getting-started/api/#examples","title":"Examples","text":""},{"location":"getting-started/api/#connect-to-device","title":"Connect to Device","text":"<p>The following code creates a <code>Scientisst</code> object and establishes a connection to the specified device.</p> <pre><code>scientisst = ScientISST(\"08:3A:F2:49:AB:DE\")\n</code></pre>"},{"location":"getting-started/api/#print-version","title":"Print Version","text":"<p>The following code prints the firmware version of the device connected with the previous command.</p> <pre><code>scientisst.version()\n</code></pre>"},{"location":"getting-started/api/#acquisition","title":"Acquisition","text":"<p>The following snippet starts streaming data from channels <code>A1</code>, <code>A2</code>, and <code>A3</code> at 100 Hz.</p> <p>Then, it reads the streaming data (by default, for frequencies not too high, 5 times per second) and prints the first <code>Frame</code>.</p> <p>After reading 1000 frames, it stops the acquisition.</p> <pre><code>scientisst.start(100, [1, 2, 3])\n\nfor i in range(50):\n    frames = scientisst.read()\n    print(frames[0])\n\nscientisst.stop()\n</code></pre>"},{"location":"getting-started/api/#disconnect","title":"Disconnect","text":"<p>Once you no longer want to use the ScientISST device, you must dispose it:</p> <pre><code>scientisst.disconnect()\n</code></pre>"},{"location":"getting-started/sense/","title":"sense.py","text":"<p><code>sense.py</code> is a script that simplifies the interaction with the ScientISST Sense.</p> <p>It allows the selection of channels, sampling rate, and duration right from the command line.</p> <p>It also implements file data saving in the background (using a different thread) and also streaming via Lab Streaming Layer (LSL).</p>"},{"location":"getting-started/sense/#usage-options","title":"Usage Options","text":"<pre><code>$ python sense.py -h\n\nusage: sense.py [args] address\n\ndescription: The program connects to the ScientISST Sense device and starts an acquisition, providing the option to store the received data in a .csv file.\n\npositional arguments:\n  address               For BTH communication:\n                                Linux: BTH MAC address\n                                Mac: serial port address\n                                Windows: BTH serial COM port\n                        For TCP/UDP communication:\n                                All plataforms: server port.\n\noptions:\n  -h, --help            show this help message and exit\n  -f FS, --frequency FS\n                        sampling frequency, default: 1000\n  -c CHANNELS, --channels CHANNELS\n                        analog channels, default: 1,2,3,4,5,6\n  -d DURATION, --duration DURATION\n                        duration in seconds, default: unlimited\n  -o OUTPUT, --output OUTPUT\n                        write report to output file, default: None\n  -r, --raw             do not convert from raw to mV\n  -s, --lsl             stream data using Lab Streaming Layer protocol. Use `python -m pylsl.examples.ReceiveAndPlot` to view stream\n  --script SCRIPT       send the received frames to a script that inherits the CustomScript class\n  -q, --quiet           don't print ScientISST frames\n  -v, --version         show sense.py version\n  --verbose             log sent/received bytes\n  -m MODE, --mode MODE  The communication mode. Currently supported modes: bt_classic, tcp, tcp_ap. Default: bt_classic\n</code></pre>"},{"location":"getting-started/sense/#automatic-selection","title":"Automatic Selection","text":"<ol> <li>Pair your device</li> <li>Run:</li> </ol> <pre><code>python sense.py\n</code></pre> <ol> <li>Select the device from the list displayed:</li> </ol> <pre><code>ScientISST devices:\n[1] ScientISST-ab-de - 08:3A:F2:49:AB:DE\n[2] ScientISST-ac-be - 08:3A:F2:49:AC:BE\nConnect to:\n</code></pre> <p>Then hit <code>CTRL-C</code> when you wish to stop.</p>"},{"location":"getting-started/sense/#manual-selection","title":"Manual Selection","text":""},{"location":"getting-started/sense/#linux","title":"Linux","text":"<p>Pair and trust the ScientISST Sense board:</p> <pre><code>bluetoothctl\nscan on\npair XX:XX:XX:XX:XX\ntrust XX:XX:XX:XX:XX\n</code></pre> <p>You can now run the <code>sense.py</code> script:</p> <pre><code>python sense.py XX:XX:XX:XX:XX\n</code></pre>"},{"location":"getting-started/sense/#mac","title":"Mac","text":"<p>First, you need to pair the ScientISST sense device in the Bluetooth Settings section. Then, you'll need to find the serial port address using the Terminal:</p> <pre><code>ls /dev/tty.ScientISST*\n</code></pre> <p>Copy the <code>String</code> like: <code>/dev/tty.ScientISST-XX-XX-SPP_SE</code>.</p> <p>You can now run the <code>sense.py</code> script:</p> <pre><code>python sense.py /dev/tty.ScientISST-XX-XX-SPP_SE\n</code></pre>"},{"location":"getting-started/sense/#windows","title":"Windows","text":"<p>Turn the ScientISST Sense board on.</p> <p>Now, go to Control Panel &gt; Hardware and Sound &gt; Devices and Printers. Select \"Add a device\". Select the ScientISST Sense board, hit \"next\" until its set up.</p> <p>While connected to the board, search \"Bluetooth settings\" on the Control Panel, then go to the \"COM ports\" tab and check the port name for the outgoing entry. Copy the <code>String</code> like: <code>COMX</code></p> <p>You can now run the <code>sense.py</code> script:</p> <pre><code>python sense.py COMX\n</code></pre>"},{"location":"getting-started/sense/#examples","title":"Examples","text":""},{"location":"getting-started/sense/#single-channel","title":"Single Channel","text":"<p>The following snippet will start streaming channel <code>A1</code>:</p> <pre><code>python sense.py -c 1\n</code></pre>"},{"location":"getting-started/sense/#frequency","title":"Frequency","text":"<p>The following snippet will start streaming channel <code>A1</code> at 100 Hz:</p> <pre><code>python sense.py -c 1 -f 100\n</code></pre>"},{"location":"getting-started/sense/#multiple-channels","title":"Multiple Channels","text":"<p>The following snippet will start streaming channels <code>A1</code>,<code>A2</code>,<code>A3</code>,<code>A4</code>:</p> <pre><code>python sense.py -c 1,2,3,4\n</code></pre>"},{"location":"getting-started/sense/#save-to-file","title":"Save to File","text":"<p>The following snippet will start recording the default channels (<code>A1</code>,<code>A2</code>,<code>A3</code>,<code>A4</code>,<code>A5</code>,<code>A6</code>) to the file <code>output.csv</code>:</p> <pre><code>python sense.py -o output.csv\n</code></pre>"},{"location":"getting-started/sense/#duration","title":"Duration","text":"<p>The following snippet will start recording the default channels for 10 seconds:</p> <pre><code>python sense.py -o output.csv -d 10\n</code></pre>"},{"location":"getting-started/sense/#lab-streaming-layer","title":"Lab Streaming Layer","text":"<p>The following snippet will start streaming the default channels using LSL:</p> <pre><code>python sense.py -s\n</code></pre>"},{"location":"getting-started/sense/#visualize-the-streaming-data-using","title":"Visualize the streaming data using:","text":"<p>Taking advantage of the LSL, it is possible to plot the real-time data:</p> <pre><code>python -m pylsl.examples.ReceiveAndPlot\n</code></pre>"},{"location":"getting-started/sense/#custom-script","title":"Custom Script","text":"<p>It is possible to run custom code every time the <code>sense.py</code> script reads data from the device. To do so, create a file, e.g. <code>hello_world.py</code>, with your own class inheriting the <code>CustomScript</code> class:</p> <pre><code>from sense import CustomScript\n\nclass HelloWorld(CustomScript):\n    def on_init(self):\n        print(\"Hello world!\")\n\n    def on_start(self):\n        print(\"Run your custom code on start\")\n\n    def on_read(self, frames):\n        print(\"Received %s frames\" % len(frames))\n\n    def on_stop(self):\n        print(\"All done\")\n</code></pre> <p>Then, you just have to provided its path:</p> <pre><code>python sense.py -d 1 -q --script hello_world.py\n</code></pre> <p>Output:</p> <pre><code>...\nConnected!\nHello world!\nStart acquisition\nRun your custom code on start\nReceived 200 frames\nReceived 200 frames\nReceived 200 frames\nReceived 200 frames\nReceived 200 frames\nStop acquisition\nAll done\nDisconnected\n</code></pre>"},{"location":"reference/exceptions-reference/","title":"Exceptions","text":""},{"location":"reference/exceptions-reference/#scientisst.exceptions.BTAdapterNotFoundError","title":"<code>BTAdapterNotFoundError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>No Bluetooth adapter was found.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class BTAdapterNotFoundError(Exception):\n\"\"\"\n    No Bluetooth adapter was found.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"No Bluetooth adapter was found.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.ContactingDeviceError","title":"<code>ContactingDeviceError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The computer lost communication with the device.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class ContactingDeviceError(Exception):\n\"\"\"\n    The computer lost communication with the device.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"The computer lost communication with the device.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotFoundError","title":"<code>DeviceNotFoundError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The device could not be found.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class DeviceNotFoundError(Exception):\n\"\"\"\n    The device could not be found.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"The device could not be found.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotIdleError","title":"<code>DeviceNotIdleError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The device is not idle.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class DeviceNotIdleError(Exception):\n\"\"\"\n    The device is not idle.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"The device is not idle.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotInAcquisitionError","title":"<code>DeviceNotInAcquisitionError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The device is not in acquisition mode.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class DeviceNotInAcquisitionError(Exception):\n\"\"\"\n    The device is not in acquisition mode.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"The device is not in acquisition mode.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.InvalidAddressError","title":"<code>InvalidAddressError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The specified address is invalid.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class InvalidAddressError(Exception):\n\"\"\"\n    The specified address is invalid.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"The specified address is invalid.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.InvalidParameterError","title":"<code>InvalidParameterError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Invalid parameter.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class InvalidParameterError(Exception):\n\"\"\"\n    Invalid parameter.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"Invalid parameter.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.NotSupportedError","title":"<code>NotSupportedError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Operation not supported by the device.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class NotSupportedError(Exception):\n\"\"\"\n    Operation not supported by the device.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"Operation not supported by the device.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.PortCouldNotBeOpenedError","title":"<code>PortCouldNotBeOpenedError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The communication port does not exist or it is already being used.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class PortCouldNotBeOpenedError(Exception):\n\"\"\"\n    The communication port does not exist or it is already being used.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\n            \"The communication port does not exist or it is already being used.\"\n        )\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.PortInitializationError","title":"<code>PortInitializationError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The communication port could not be initialized.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class PortInitializationError(Exception):\n\"\"\"\n    The communication port could not be initialized.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"The communication port could not be initialized.\")\n</code></pre>"},{"location":"reference/exceptions-reference/#scientisst.exceptions.UnknownError","title":"<code>UnknownError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Unknown error: <code>message</code>.</p> Source code in <code>scientisst/exceptions.py</code> <pre><code>class UnknownError(Exception):\n\"\"\"\n    Unknown error: `message`.\n    \"\"\"\n\n    def __init__(self, message=\"\"):\n        super().__init__(\"Unknown error: {}\".format(message))\n</code></pre>"},{"location":"reference/frame-reference/","title":"Frame","text":""},{"location":"reference/frame-reference/#scientisst.frame.Frame","title":"<code>Frame</code>","text":"<p>ScientISST Device Frame class</p> <p>A frame returned by ScientISST.read()</p> <p>Attributes:</p> Name Type Description <code>seq</code> <code>int</code> <p>Frame sequence number (0...15).</p> <p>This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number).</p> <p>This number can be used to detect if frames were dropped while transmitting data.</p> <code>digital</code> <code>list</code> <p>Array of digital ports states (False for low level or True for high level).</p> <p>On original ScientISST, the array contents are: I1 I2 I3 I4.</p> <p>On ScientISST 2, the array contents are: I1 I2 O1 O2.</p> <code>a</code> <code>list</code> <p>Array of raw analog inputs values of the active channles.</p> <p>If all channels are active, <code>a</code> will have 8 elements: 6 AIs and 2 AXs.</p> <code>mv</code> <code>list</code> <p>Array of analog inputs values of the active channles in mV.</p> <p>If all channels are active, <code>mv</code> will have 8 elements: 6 AIs and 2 AXs.</p> Source code in <code>scientisst/frame.py</code> <pre><code>class Frame:\n\"\"\"\n    ScientISST Device Frame class\n\n    A frame returned by ScientISST.read()\n\n    Attributes:\n        seq (int): Frame sequence number (0...15).\n\n            This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number).\n\n            This number can be used to detect if frames were dropped while transmitting data.\n\n        digital (list): Array of digital ports states (False for low level or True for high level).\n\n            On original ScientISST, the array contents are: I1 I2 I3 I4.\n\n            On ScientISST 2, the array contents are: I1 I2 O1 O2.\n\n        a (list): Array of raw analog inputs values of the active channles.\n\n            If all channels are active, `a` will have 8 elements: 6 AIs and 2 AXs.\n\n        mv (list): Array of analog inputs values of the active channles in mV.\n\n            If all channels are active, `mv` will have 8 elements: 6 AIs and 2 AXs.\n    \"\"\"\n\n    digital = [0] * 4\n    seq = -1\n\n    def __init__(self, num_channels):\n        self.a = [0] * num_channels\n        self.mv = [0] * num_channels\n\n    def to_map(self):\n        return {\n            \"sequence\": self.seq,\n            \"analog\": self.a,\n            \"digital\": self.digital,\n            \"mv\": self.mv,\n        }\n\n    def __str__(self):\n        if self.mv[0]:\n            values = [str(val) for pair in zip(self.a, self.mv) for val in pair]\n        else:\n            values = map(str, self.a)\n\n        return \"{}\\t{}\\t{}\\t{}\\t{}\\t{}\".format(\n            self.seq,\n            self.digital[0],\n            self.digital[1],\n            self.digital[2],\n            self.digital[3],\n            \"\\t\".join(values),\n        )\n\n    def to_matrix(self):\n        if self.mv[0]:\n            return (\n                [self.seq]\n                + self.digital\n                + [val for pair in zip(self.a, self.mv) for val in pair]\n            )\n        else:\n            return [self.seq] + self.digital + self.a\n</code></pre>"},{"location":"reference/scientisst-reference/","title":"ScientISST","text":""},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST","title":"<code>ScientISST</code>","text":"<p>ScientISST Device class</p> <p>Attributes:</p> Name Type Description <code>address</code> <code>str</code> <p>The device serial port address (\"/dev/example\") or TCP port</p> <code>serial_speed</code> <code>int</code> <p>The serial port bitrate.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>class ScientISST:\n\"\"\"ScientISST Device class\n\n    Attributes:\n        address (str): The device serial port address (\"/dev/example\") or TCP port\n\n        serial_speed (int, optional): The serial port bitrate.\n    \"\"\"\n\n    __serial = None\n    __socket = None\n    __num_chs = 0\n    __api_mode = 1\n    __sample_rate = None\n    __chs = [None] * 8\n    __log = False\n\n    def __init__(\n        self,\n        address,\n        serial_speed=115200,\n        log=False,\n        api=API_MODE_SCIENTISST,\n        connection_tries=5,\n        com_mode=COM_MODE_BT,\n    ):\n\"\"\"\n        Args:\n            address (str): The device serial port address (\"/dev/example\")\n            serial_speed (int, optional): The serial port bitrate in bit/s\n            log (bool, optional): If the bytes sent and received should be showed\n            api (int): The desired API mode for the device\n        \"\"\"\n\n        if (\n            api != API_MODE_SCIENTISST\n            and api != API_MODE_JSON\n            and api != API_MODE_BITALINO\n        ):\n            raise InvalidParameterError()\n\n        self.com_mode = com_mode\n        self.address = address\n        self.serial_speed = serial_speed\n        self.__log = log\n\n        self.__serial = None\n        self.__socket = None\n        self.__num_chs = 0\n        self.__api_mode = 1\n        self.__sample_rate = None\n        self.__chs = [None] * 8\n        self.__log = False\n\n        # Setup socket in function of com_mode argument\n        self.__setupSocket()\n\n        # try to connect to board\n        while True:\n            try:\n                # Set API mode\n                self.__changeAPI(api)\n                # get device version string and adc characteristics\n                self.version_and_adc_chars()\n                break\n            except ContactingDeviceError:\n                if connection_tries &gt; 0:\n                    connection_tries -= 1\n                else:\n                    raise ContactingDeviceError()\n\n        sys.stdout.write(\"Connected!\\n\")\n\n    def version_and_adc_chars(self, print=True):\n\"\"\"\n        Gets the device firmware version string and esp_adc_characteristics\n\n        Returns:\n            version (str): Firmware version\n\n        Raises:\n            ContactingDeviceError: If there is an error contacting the device.\n        \"\"\"\n        if self.__api_mode == API_MODE_BITALINO:\n            header = \"BITalino\"\n        else:\n            header = \"ScientISST\"\n        header_len = len(header)\n\n        cmd = b\"\\x07\"\n        self.__send(cmd)\n\n        result = self.__recv(1024, waitall_flag=False)\n\n        if result == b\"\":\n            raise ContactingDeviceError()\n\n        index = result.index(b\"\\x00\")\n        version = result[header_len : index - 1].decode(\"utf-8\")\n\n        self.__adc1_chars = EspAdcCalChars(result[index + 1 :])\n\n        if print:\n            sys.stdout.write(\"ScientISST version: {}\\n\".format(version))\n            sys.stdout.write(\n                \"ScientISST Board Vref: {}\\n\".format(self.__adc1_chars.vref)\n            )\n            sys.stdout.write(\n                \"ScientISST Board ADC Attenuation Mode: {}\\n\".format(\n                    self.__adc1_chars.atten\n                )\n            )\n\n        return version\n\n    def start(\n        self,\n        sample_rate,\n        channels,\n        reads_per_second=5,\n        simulated=False,\n    ):\n\"\"\"\n        Starts a signal acquisition from the device\n\n        Args:\n            sample_rate (int): Sampling rate in Hz.\n\n                Accepted values are 1, 10, 100 or 1000 Hz.\n\n            channels (list): Set of channels to acquire.\n\n                Accepted channels are 1...6 for inputs A1...A6.\n\n            reads_per_second (int): Number of times to read the data streaming from the device.\n\n                Accepted values are integers greater than 0.\n\n\n            simulated (bool): If true, start in simulated mode.\n\n                Otherwise start in live mode. Default is to start in live mode.\n\n        Raises:\n            DeviceNotIdleError: If the device is already in acquisition mode.\n            InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided.\n        \"\"\"\n        assert int(reads_per_second) &gt; 0\n\n        if self.__num_chs != 0:\n            raise DeviceNotIdleError()\n\n        if not channels:  # channels is empty\n            chMask = 0xFF  #  all 8 analog channels\n            self.__num_chs = 8\n        else:\n            chMask = 0\n            for ch in channels:\n                if ch &lt;= 0 or ch &gt; 8:\n                    raise InvalidParameterError()\n                self.__chs[self.__num_chs] = ch  # Fill chs vector\n\n                mask = 1 &lt;&lt; (ch - 1)\n                if chMask &amp; mask:\n                    self.__num_chs = 0\n                    raise InvalidParameterError()\n\n                chMask |= mask\n                self.__num_chs += 1\n\n        self.__sample_rate = sample_rate\n\n        # Sample rate\n        sr = 0b01000011\n        sr |= self.__sample_rate &lt;&lt; 8\n        self.__send(sr, 4)\n\n        # Cleanup existing data in bluetooth socket\n        self.__clear()\n\n        if simulated:\n            cmd = 0x02\n        else:\n            cmd = 0x01\n        cmd |= chMask &lt;&lt; 8\n\n        self.__send(cmd)\n\n        self.__packet_size = self.__getPacketSize()\n\n        self.__bytes_to_read = self.__packet_size * max(\n            sample_rate // reads_per_second, 1\n        )\n        if self.__bytes_to_read &gt; MAX_BUFFER_SIZE:\n            self.__bytes_to_read = MAX_BUFFER_SIZE - (\n                MAX_BUFFER_SIZE % self.__packet_size\n            )\n\n        if self.__bytes_to_read % self.__packet_size:\n            self.__num_chs = 0\n            sys.stderr.write(\n                \"Error, bytes_to_read needs to be devisible by packet_size\\n\"\n            )\n            raise InvalidParameterError()\n        else:\n            self.__num_frames = self.__bytes_to_read // self.__packet_size\n\n    def read(self, convert=True, matrix=False):\n\"\"\"\n        Reads acquisition frames from the device.\n\n        This method returns when all requested frames are received from the device, or when a timeout occurs.\n\n        Args:\n            convert (bool): Convert from raw to mV\n            matrix (bool): Return `Frames` in a `np.array` (matrix) form\n\n        Returns:\n            frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device. If `matrix` is True, the `frames` corresponds to a `np.array` (matrix).\n\n        Raises:\n            ContactingDeviceError: If there is an error contacting the device.\n            DeviceNotInAcquisitionError: If the device is not in acquisition mode.\n            NotSupportedError: If the device API is in BITALINO mode\n            UnknownError: If the device stopped sending frames for some unknown reason.\n        \"\"\"\n\n        frames = []\n\n        if self.__num_chs == 0:\n            raise DeviceNotInAcquisitionError()\n\n        result = list(self.__recv(self.__bytes_to_read))\n        start = 0\n        for it in range(self.__num_frames):\n            bf = result[start : start + self.__packet_size]\n            mid_frame_flag = 0\n\n            #  if CRC check failed, try to resynchronize with the next valid frame\n            while not self.__checkCRC4(bf, self.__packet_size):\n                sys.stderr.write(\"Error checking CRC4\\n\")\n                #  checking with one new byte at a time\n                result_tmp = list(self.__recv(1))\n                if len(result_tmp) != 1:\n                    raise ContactingDeviceError()\n\n                result += result_tmp\n                start += 1\n                bf = result[start : start + self.__packet_size]\n\n            f = Frame(self.__num_chs)\n            frames.append(f)\n            if self.__api_mode == API_MODE_SCIENTISST:\n                # Get seq number and IO states\n                f.seq = bf[-2] &gt;&gt; 4 | bf[-1] &lt;&lt; 4\n                for i in range(4):\n                    f.digital[i] = 0 if (bf[-3] &amp; (0x80 &gt;&gt; i)) == 0 else 1\n\n                # Get channel values\n                byte_it = 0\n                for i in range(self.__num_chs):\n                    index = self.__num_chs - 1 - i\n                    curr_ch = self.__chs[index]\n\n                    # If it's an AX channel\n                    if curr_ch == AX1 or curr_ch == AX2:\n                        f.a[index] = (\n                            int.from_bytes(\n                                bf[byte_it : byte_it + 4], byteorder=\"little\"\n                            )\n                            &amp; 0xFFFFFF\n                        )\n                        byte_it += 3\n                        if convert:\n                            f.mv[index] = ((f.a[index]) * (3.3*2) / (pow(2, 24) - 1))*1000\n                            f.mv[index] = round(f.mv[index], 3)\n\n                    # If it's an AI channel\n                    else:\n                        if not mid_frame_flag:\n                            f.a[index] = (\n                                int.from_bytes(\n                                    bf[byte_it : byte_it + 2], byteorder=\"little\"\n                                )\n                                &amp; 0xFFF\n                            )\n                            byte_it += 1\n                            mid_frame_flag = 1\n                        else:\n                            f.a[index] = (\n                                int.from_bytes(\n                                    bf[byte_it : byte_it + 2], byteorder=\"little\"\n                                )\n                                &gt;&gt; 4\n                            )\n                            byte_it += 2\n                            mid_frame_flag = 0\n                        if convert:\n                            f.mv[index] = self.__adc1_chars.esp_adc_cal_raw_to_voltage(\n                                f.a[index]\n                            )\n            elif self.__api_mode == API_MODE_JSON:\n                print(bf)\n            else:\n                raise NotSupportedError()\n\n            start += self.__packet_size\n\n        if len(frames) == self.__num_frames:\n            if not matrix:\n                return frames\n            else:\n                return np.array([frame.to_matrix() for frame in frames])\n        else:\n            raise ContactingDeviceError()\n\n    def stop(self):\n\"\"\"\n        Stops a signal acquisition.\n\n        Raises:\n            DeviceNotInAcquisitionError: If the device is not in acquisition mode.\n        \"\"\"\n        if self.__num_chs == 0:\n            raise DeviceNotInAcquisitionError()\n\n        cmd = b\"\\x00\"\n        self.__send(cmd)  # 0  0  0  0  0  0  0  0 - Go to idle mode\n\n        self.__num_chs = 0\n        self.__sample_rate = 0\n\n        # Cleanup existing data in bluetooth socket\n        self.__clear()\n\n    def battery(self, value=0):\n\"\"\"\n        Sets the battery voltage threshold for the low-battery LED.\n\n        Args:\n            value (int): Battery voltage threshold. Default value is 0.\n\n                Value | Voltage Threshold\n                ----- | -----------------\n                    0 |   3.4 V\n                 ...  |   ...\n                   63 |   3.8 V\n\n        Raises:\n            DeviceNotIdleError: If the device is in acquisition mode.\n            InvalidParameterError: If an invalid battery threshold value is given.\n        \"\"\"\n        if self.__num_chs != 0:\n            raise DeviceNotIdleError()\n\n        if value &lt; 0 or value &gt; 63:\n            raise InvalidParameterError()\n\n        cmd = value &lt;&lt; 2\n        # &lt;bat threshold&gt; 0 0 - Set battery threshold\n        self.__send(cmd)\n\n    def trigger(self, digital_output):\n\"\"\"\n        Assigns the digital outputs states.\n\n        Args:\n            digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1).\n\n        Raises:\n            InvalidParameterError: If the length of the digital_output array is different from 2.\n        \"\"\"\n        length = len(digital_output)\n\n        if length != 2:\n            raise InvalidParameterError()\n\n        cmd = 0xB3  # 1  0  1  1  O2 O1 1  1 - Set digital outputs\n\n        for i in range(length):\n            if digital_output[i]:\n                cmd |= 0b100 &lt;&lt; i\n\n        self.__send(cmd)\n\n    def dac(self, voltage):\n\"\"\"\n        Assigns the analog (DAC) output value (ScientISST 2 only).\n\n        Args:\n            voltage (float): Analog output value to set (0V-3.3V).\n\n        Raises:\n            InvalidParameterError: If the voltage value is outside of its range, 0-255.\n        \"\"\"\n        if voltage &lt; 0 or voltage &gt; 3.3:\n            raise InvalidParameterError()\n\n        cmd = 0xA3  # 1  0  1  0  0  0  1  1 - Set dac output\n\n        # Convert from voltage to raw:\n        raw = int(voltage * 255 / 3.3)\n\n        cmd |= raw &lt;&lt; 8\n        self.__send(cmd, nrOfBytes=2)\n\n    # TODO: test with ScientISST Sense v2\n    def state(self):\n\"\"\"\n        Returns current device state (%ScientISST 2 only).\n\n        Returns:\n            state (State): Current device [`State`][scientisst.state.State]\n\n        Raises:\n            DeviceNotIdleError: If the device is in acquisition mode.\n            ContactingDeviceError: If there is an error contacting the device.\n        \"\"\"\n        if self.__num_chs != 0:\n            raise DeviceNotIdleError()\n\n        cmd = 0x0B\n        self.__send(cmd)\n        # 0  0  0  0  1  0  1  1 - Send device status\n\n        # if (recv(&amp;statex, sizeof statex) != sizeof statex)    # a timeout has occurred\n        # throw Exception(Exception::CONTACTING_DEVICE);\n        result = self.__recv(16)\n        if not result or not self.__checkCRC4(result, 16):\n            raise ContactingDeviceError()\n\n        state = State()\n        print(result)\n\n        # for(int i = 0; i &lt; 6; i++)\n        # state.analog[i] = statex.analog[i];\n\n        # state.battery = statex.battery;\n        # state.batThreshold = statex.batThreshold;\n\n        # for(int i = 0; i &lt; 4; i++)\n        # state.digital[i] = ((statex.portsCRC &amp; (0x80 &gt;&gt; i)) != 0);\n\n        # return state;\n\n    def disconnect(self):\n\"\"\"\n        Disconnects from a ScientISST device. If an aquisition is running, it is stopped\n        \"\"\"\n        if self.__num_chs != 0:\n            self.stop()\n        if self.__socket:\n            self.__socket.shutdown(socket.SHUT_RDWR)\n            self.__socket.close()\n            self.__socket = None\n        elif self.__serial:\n            self.__serial.close()\n            self.__serial = None\n        sys.stdout.write(\"Disconnected\\n\")\n\n    def __setupSocket(self):\n\"\"\"\n        Create a socket in function of the comunication mode desired\n        \"\"\"\n        if self.com_mode == COM_MODE_BT:\n            sys.stdout.write(\"Connecting to {}...\\n\".format(self.address))\n            # Create the client socket\n            if sys.platform == \"linux\":\n                # Check if address is a valid bt MAC address\n                if not re.match(\n                    \"[0-9a-f]{2}([-:]?)[0-9a-f]{2}(\\\\1[0-9a-f]{2}){4}$\",\n                    self.address.lower(),\n                ):\n                    raise InvalidAddressError()\n\n                self.__socket = socket.socket(\n                    socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM\n                )\n                self.__socket.connect((self.address, 1))\n                self.__socket.settimeout(TIMEOUT_IN_SECONDS)\n            else:\n                self.__serial = serial.Serial(\n                    self.address, self.serial_speed, timeout=TIMEOUT_IN_SECONDS\n                )\n        elif self.com_mode == COM_MODE_TCP_SERVER:\n            if not self.address.isdigit():\n                raise InvalidAddressError()\n\n            port = int(self.address)\n\n            with socket.socket() as s:\n                s.bind((\"\", port))\n                print(\"Binded port %d on all interfaces\" % (port))\n\n                s.listen(5)\n                print(\"TCP Server created. Waiting for ScientISST to connect...\")\n\n                self.__socket, addr = s.accept()\n                print(\"ScientISST with address\", addr, \" connected\")\n\n        elif self.com_mode == COM_MODE_TCP_AP:\n            if isinstance(self.address, str):\n                if not self.address.isdigit():\n                    raise InvalidAddressError()\n                port = int(self.address)\n            elif isinstance(self.address, int):\n                port = self.address\n            else:\n                raise InvalidAddressError()\n\n            self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.__socket.connect((\"scientisst.local\", port))\n\n        else:\n            raise InvalidParameterError\n\n    def __getPacketSize(self):\n        packet_size = 0\n\n        if self.__api_mode == API_MODE_SCIENTISST:\n            num_intern_active_chs = 0\n            num_extern_active_chs = 0\n\n            for ch in self.__chs:\n                if ch:\n                    # Add 24bit channel's contributuion to packet size\n                    if ch == AX1 or ch == AX2:\n                        num_extern_active_chs += 1\n                    # Count 12bit channels\n                    else:\n                        num_intern_active_chs += 1\n\n            # Add 24bit channel's contributuion to packet size\n            packet_size = 3 * num_extern_active_chs\n\n            # Add 12bit channel's contributuion to packet size\n            if not (num_intern_active_chs % 2):  # If it's an even number\n                packet_size += (num_intern_active_chs * 12) / 8\n            else:\n                packet_size += (\n                    (num_intern_active_chs * 12) - 4\n                ) / 8  # -4 because 4 bits can go in the I/0 byte\n            # for the I/Os and seq+crc bytes\n            packet_size += 3\n\n        else:\n            raise NotSupportedError()\n\n        return int(packet_size)\n\n    def __changeAPI(self, api):\n        if self.__num_chs and self.__num_chs != 0:\n            raise DeviceNotIdleError()\n\n        if api &lt;= 0 or api &gt; 3:\n            raise InvalidParameterError()\n\n        self.__api_mode = api\n\n        api &lt;&lt;= 4\n        api |= 0b11\n\n        self.__send(api)\n\n    def __checkCRC4(self, data, length):\n        CRC4tab = [0, 3, 6, 5, 12, 15, 10, 9, 11, 8, 13, 14, 7, 4, 1, 2]\n        crc = 0\n        for i in range(length - 2):\n            b = data[i]\n            crc = CRC4tab[crc] ^ (b &gt;&gt; 4)\n            crc = CRC4tab[crc] ^ (b &amp; 0x0F)\n\n        # CRC for seq\n        crc = CRC4tab[crc] ^ (data[-2] &gt;&gt; 4)        #First 4 bits\n        #Last 8 bits of seq\n        crc = CRC4tab[crc] ^ (data[-1] &gt;&gt; 4)\n        crc = CRC4tab[crc] ^ (data[-1] &amp; 0x0F)\n\n        crc = CRC4tab[crc]\n\n        return crc == (data[-2] &amp; 0x0F)\n\n    def __send(self, command, nrOfBytes=0):\n\"\"\"\n        Send data\n        \"\"\"\n\n        if nrOfBytes &lt;= 4:\n            nrOfBytes = 4\n        else:\n            raise ValueError(\"Maximum send command size is 4 bytes\")\n\n        if type(command) is int:\n            if command != 0:\n                command = command.to_bytes(\n                    int(log2(command) // 8 + 1), byteorder=\"little\"\n                )\n            else:\n                command = b\"\\x00\"\n        if nrOfBytes and len(command) &lt; nrOfBytes:\n            for _ in range(nrOfBytes - len(command)):\n                command += b\"\\x00\"\n        # if self.__serial:\n        time.sleep(0.250)\n        if self.__log:\n            sys.stdout.write(\n                \"{} bytes sent: {}\\n\".format(\n                    len(command), \" \".join(\"{:02x}\".format(c) for c in command)\n                )\n            )\n        if self.__socket:\n            self.__socket.send(command)\n        elif self.__serial:\n            self.__serial.write(command)\n        else:\n            raise InvalidParameterError()\n        # else:\n        # raise ContactingDeviceError()\n\n    def __recv(self, nrOfBytes, waitall_flag=True):\n\"\"\"\n        Receive data\n        \"\"\"\n        result = b\"\"\n        if self.__socket:\n            # We have to use a select here with a single socket because we can't apply a timeout in any other way\n            ready = select.select([self.__socket], [], [], 5)  # 10 seconds timeout\n            if ready[0]:\n                if waitall_flag:\n                    remaining = nrOfBytes\n                    while remaining &gt; 0:\n                        ready = select.select([self.__socket], [], [], 10)\n                        if not ready[0]:\n                            raise ContactingDeviceError()\n                        temp = self.__socket.recv(remaining)\n                        result += temp\n                        remaining = nrOfBytes - len(result)\n                else:\n                    result = self.__socket.recv(nrOfBytes)\n        elif self.__serial:\n            result = self.__serial.read(nrOfBytes)\n        else:\n            raise InvalidParameterError()\n        if self.__log:\n            if nrOfBytes &gt; 1:\n                sys.stdout.write(\n                    \"{} bytes received: {}\\n\".format(\n                        nrOfBytes, \" \".join(\"{:02x}\".format(c) for c in result)\n                    )\n                )\n            else:\n                sys.stdout.write(\"{} bytes received: {}\\n\".format(1, result.hex()))\n        return result\n\n    def __clear(self):\n\"\"\"\n        Clear the device buffer\n        \"\"\"\n        if self.__socket:\n            self.__socket.setblocking(False)\n        elif self.__serial:\n            self.__serial.timeout = 0\n        else:\n            raise InvalidParameterError()\n\n        try:\n            while self.__recv(1):\n                pass\n        except BlockingIOError:\n            pass\n\n        if self.__socket:\n            self.__socket.setblocking(True)\n        elif self.__serial:\n            self.__serial.timeout = TIMEOUT_IN_SECONDS\n        else:\n            raise InvalidParameterError()\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__clear","title":"<code>__clear()</code>","text":"<p>Clear the device buffer</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def __clear(self):\n\"\"\"\n    Clear the device buffer\n    \"\"\"\n    if self.__socket:\n        self.__socket.setblocking(False)\n    elif self.__serial:\n        self.__serial.timeout = 0\n    else:\n        raise InvalidParameterError()\n\n    try:\n        while self.__recv(1):\n            pass\n    except BlockingIOError:\n        pass\n\n    if self.__socket:\n        self.__socket.setblocking(True)\n    elif self.__serial:\n        self.__serial.timeout = TIMEOUT_IN_SECONDS\n    else:\n        raise InvalidParameterError()\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__init__","title":"<code>__init__(address, serial_speed=115200, log=False, api=API_MODE_SCIENTISST, connection_tries=5, com_mode=COM_MODE_BT)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The device serial port address (\"/dev/example\")</p> required <code>serial_speed</code> <code>int</code> <p>The serial port bitrate in bit/s</p> <code>115200</code> <code>log</code> <code>bool</code> <p>If the bytes sent and received should be showed</p> <code>False</code> <code>api</code> <code>int</code> <p>The desired API mode for the device</p> <code>API_MODE_SCIENTISST</code> Source code in <code>scientisst/scientisst.py</code> <pre><code>def __init__(\n    self,\n    address,\n    serial_speed=115200,\n    log=False,\n    api=API_MODE_SCIENTISST,\n    connection_tries=5,\n    com_mode=COM_MODE_BT,\n):\n\"\"\"\n    Args:\n        address (str): The device serial port address (\"/dev/example\")\n        serial_speed (int, optional): The serial port bitrate in bit/s\n        log (bool, optional): If the bytes sent and received should be showed\n        api (int): The desired API mode for the device\n    \"\"\"\n\n    if (\n        api != API_MODE_SCIENTISST\n        and api != API_MODE_JSON\n        and api != API_MODE_BITALINO\n    ):\n        raise InvalidParameterError()\n\n    self.com_mode = com_mode\n    self.address = address\n    self.serial_speed = serial_speed\n    self.__log = log\n\n    self.__serial = None\n    self.__socket = None\n    self.__num_chs = 0\n    self.__api_mode = 1\n    self.__sample_rate = None\n    self.__chs = [None] * 8\n    self.__log = False\n\n    # Setup socket in function of com_mode argument\n    self.__setupSocket()\n\n    # try to connect to board\n    while True:\n        try:\n            # Set API mode\n            self.__changeAPI(api)\n            # get device version string and adc characteristics\n            self.version_and_adc_chars()\n            break\n        except ContactingDeviceError:\n            if connection_tries &gt; 0:\n                connection_tries -= 1\n            else:\n                raise ContactingDeviceError()\n\n    sys.stdout.write(\"Connected!\\n\")\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__recv","title":"<code>__recv(nrOfBytes, waitall_flag=True)</code>","text":"<p>Receive data</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def __recv(self, nrOfBytes, waitall_flag=True):\n\"\"\"\n    Receive data\n    \"\"\"\n    result = b\"\"\n    if self.__socket:\n        # We have to use a select here with a single socket because we can't apply a timeout in any other way\n        ready = select.select([self.__socket], [], [], 5)  # 10 seconds timeout\n        if ready[0]:\n            if waitall_flag:\n                remaining = nrOfBytes\n                while remaining &gt; 0:\n                    ready = select.select([self.__socket], [], [], 10)\n                    if not ready[0]:\n                        raise ContactingDeviceError()\n                    temp = self.__socket.recv(remaining)\n                    result += temp\n                    remaining = nrOfBytes - len(result)\n            else:\n                result = self.__socket.recv(nrOfBytes)\n    elif self.__serial:\n        result = self.__serial.read(nrOfBytes)\n    else:\n        raise InvalidParameterError()\n    if self.__log:\n        if nrOfBytes &gt; 1:\n            sys.stdout.write(\n                \"{} bytes received: {}\\n\".format(\n                    nrOfBytes, \" \".join(\"{:02x}\".format(c) for c in result)\n                )\n            )\n        else:\n            sys.stdout.write(\"{} bytes received: {}\\n\".format(1, result.hex()))\n    return result\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__send","title":"<code>__send(command, nrOfBytes=0)</code>","text":"<p>Send data</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def __send(self, command, nrOfBytes=0):\n\"\"\"\n    Send data\n    \"\"\"\n\n    if nrOfBytes &lt;= 4:\n        nrOfBytes = 4\n    else:\n        raise ValueError(\"Maximum send command size is 4 bytes\")\n\n    if type(command) is int:\n        if command != 0:\n            command = command.to_bytes(\n                int(log2(command) // 8 + 1), byteorder=\"little\"\n            )\n        else:\n            command = b\"\\x00\"\n    if nrOfBytes and len(command) &lt; nrOfBytes:\n        for _ in range(nrOfBytes - len(command)):\n            command += b\"\\x00\"\n    # if self.__serial:\n    time.sleep(0.250)\n    if self.__log:\n        sys.stdout.write(\n            \"{} bytes sent: {}\\n\".format(\n                len(command), \" \".join(\"{:02x}\".format(c) for c in command)\n            )\n        )\n    if self.__socket:\n        self.__socket.send(command)\n    elif self.__serial:\n        self.__serial.write(command)\n    else:\n        raise InvalidParameterError()\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__setupSocket","title":"<code>__setupSocket()</code>","text":"<p>Create a socket in function of the comunication mode desired</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def __setupSocket(self):\n\"\"\"\n    Create a socket in function of the comunication mode desired\n    \"\"\"\n    if self.com_mode == COM_MODE_BT:\n        sys.stdout.write(\"Connecting to {}...\\n\".format(self.address))\n        # Create the client socket\n        if sys.platform == \"linux\":\n            # Check if address is a valid bt MAC address\n            if not re.match(\n                \"[0-9a-f]{2}([-:]?)[0-9a-f]{2}(\\\\1[0-9a-f]{2}){4}$\",\n                self.address.lower(),\n            ):\n                raise InvalidAddressError()\n\n            self.__socket = socket.socket(\n                socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM\n            )\n            self.__socket.connect((self.address, 1))\n            self.__socket.settimeout(TIMEOUT_IN_SECONDS)\n        else:\n            self.__serial = serial.Serial(\n                self.address, self.serial_speed, timeout=TIMEOUT_IN_SECONDS\n            )\n    elif self.com_mode == COM_MODE_TCP_SERVER:\n        if not self.address.isdigit():\n            raise InvalidAddressError()\n\n        port = int(self.address)\n\n        with socket.socket() as s:\n            s.bind((\"\", port))\n            print(\"Binded port %d on all interfaces\" % (port))\n\n            s.listen(5)\n            print(\"TCP Server created. Waiting for ScientISST to connect...\")\n\n            self.__socket, addr = s.accept()\n            print(\"ScientISST with address\", addr, \" connected\")\n\n    elif self.com_mode == COM_MODE_TCP_AP:\n        if isinstance(self.address, str):\n            if not self.address.isdigit():\n                raise InvalidAddressError()\n            port = int(self.address)\n        elif isinstance(self.address, int):\n            port = self.address\n        else:\n            raise InvalidAddressError()\n\n        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.__socket.connect((\"scientisst.local\", port))\n\n    else:\n        raise InvalidParameterError\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.battery","title":"<code>battery(value=0)</code>","text":"<p>Sets the battery voltage threshold for the low-battery LED.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Battery voltage threshold. Default value is 0.</p> Value Voltage Threshold 0 3.4 V ... ... 63 3.8 V <code>0</code> <p>Raises:</p> Type Description <code>DeviceNotIdleError</code> <p>If the device is in acquisition mode.</p> <code>InvalidParameterError</code> <p>If an invalid battery threshold value is given.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def battery(self, value=0):\n\"\"\"\n    Sets the battery voltage threshold for the low-battery LED.\n\n    Args:\n        value (int): Battery voltage threshold. Default value is 0.\n\n            Value | Voltage Threshold\n            ----- | -----------------\n                0 |   3.4 V\n             ...  |   ...\n               63 |   3.8 V\n\n    Raises:\n        DeviceNotIdleError: If the device is in acquisition mode.\n        InvalidParameterError: If an invalid battery threshold value is given.\n    \"\"\"\n    if self.__num_chs != 0:\n        raise DeviceNotIdleError()\n\n    if value &lt; 0 or value &gt; 63:\n        raise InvalidParameterError()\n\n    cmd = value &lt;&lt; 2\n    # &lt;bat threshold&gt; 0 0 - Set battery threshold\n    self.__send(cmd)\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.dac","title":"<code>dac(voltage)</code>","text":"<p>Assigns the analog (DAC) output value (ScientISST 2 only).</p> <p>Parameters:</p> Name Type Description Default <code>voltage</code> <code>float</code> <p>Analog output value to set (0V-3.3V).</p> required <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the voltage value is outside of its range, 0-255.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def dac(self, voltage):\n\"\"\"\n    Assigns the analog (DAC) output value (ScientISST 2 only).\n\n    Args:\n        voltage (float): Analog output value to set (0V-3.3V).\n\n    Raises:\n        InvalidParameterError: If the voltage value is outside of its range, 0-255.\n    \"\"\"\n    if voltage &lt; 0 or voltage &gt; 3.3:\n        raise InvalidParameterError()\n\n    cmd = 0xA3  # 1  0  1  0  0  0  1  1 - Set dac output\n\n    # Convert from voltage to raw:\n    raw = int(voltage * 255 / 3.3)\n\n    cmd |= raw &lt;&lt; 8\n    self.__send(cmd, nrOfBytes=2)\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects from a ScientISST device. If an aquisition is running, it is stopped</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def disconnect(self):\n\"\"\"\n    Disconnects from a ScientISST device. If an aquisition is running, it is stopped\n    \"\"\"\n    if self.__num_chs != 0:\n        self.stop()\n    if self.__socket:\n        self.__socket.shutdown(socket.SHUT_RDWR)\n        self.__socket.close()\n        self.__socket = None\n    elif self.__serial:\n        self.__serial.close()\n        self.__serial = None\n    sys.stdout.write(\"Disconnected\\n\")\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.read","title":"<code>read(convert=True, matrix=False)</code>","text":"<p>Reads acquisition frames from the device.</p> <p>This method returns when all requested frames are received from the device, or when a timeout occurs.</p> <p>Parameters:</p> Name Type Description Default <code>convert</code> <code>bool</code> <p>Convert from raw to mV</p> <code>True</code> <code>matrix</code> <code>bool</code> <p>Return <code>Frames</code> in a <code>np.array</code> (matrix) form</p> <code>False</code> <p>Returns:</p> Name Type Description <code>frames</code> <code>list</code> <p>List of <code>Frame</code> objects retrieved from the device. If <code>matrix</code> is True, the <code>frames</code> corresponds to a <code>np.array</code> (matrix).</p> <p>Raises:</p> Type Description <code>ContactingDeviceError</code> <p>If there is an error contacting the device.</p> <code>DeviceNotInAcquisitionError</code> <p>If the device is not in acquisition mode.</p> <code>NotSupportedError</code> <p>If the device API is in BITALINO mode</p> <code>UnknownError</code> <p>If the device stopped sending frames for some unknown reason.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def read(self, convert=True, matrix=False):\n\"\"\"\n    Reads acquisition frames from the device.\n\n    This method returns when all requested frames are received from the device, or when a timeout occurs.\n\n    Args:\n        convert (bool): Convert from raw to mV\n        matrix (bool): Return `Frames` in a `np.array` (matrix) form\n\n    Returns:\n        frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device. If `matrix` is True, the `frames` corresponds to a `np.array` (matrix).\n\n    Raises:\n        ContactingDeviceError: If there is an error contacting the device.\n        DeviceNotInAcquisitionError: If the device is not in acquisition mode.\n        NotSupportedError: If the device API is in BITALINO mode\n        UnknownError: If the device stopped sending frames for some unknown reason.\n    \"\"\"\n\n    frames = []\n\n    if self.__num_chs == 0:\n        raise DeviceNotInAcquisitionError()\n\n    result = list(self.__recv(self.__bytes_to_read))\n    start = 0\n    for it in range(self.__num_frames):\n        bf = result[start : start + self.__packet_size]\n        mid_frame_flag = 0\n\n        #  if CRC check failed, try to resynchronize with the next valid frame\n        while not self.__checkCRC4(bf, self.__packet_size):\n            sys.stderr.write(\"Error checking CRC4\\n\")\n            #  checking with one new byte at a time\n            result_tmp = list(self.__recv(1))\n            if len(result_tmp) != 1:\n                raise ContactingDeviceError()\n\n            result += result_tmp\n            start += 1\n            bf = result[start : start + self.__packet_size]\n\n        f = Frame(self.__num_chs)\n        frames.append(f)\n        if self.__api_mode == API_MODE_SCIENTISST:\n            # Get seq number and IO states\n            f.seq = bf[-2] &gt;&gt; 4 | bf[-1] &lt;&lt; 4\n            for i in range(4):\n                f.digital[i] = 0 if (bf[-3] &amp; (0x80 &gt;&gt; i)) == 0 else 1\n\n            # Get channel values\n            byte_it = 0\n            for i in range(self.__num_chs):\n                index = self.__num_chs - 1 - i\n                curr_ch = self.__chs[index]\n\n                # If it's an AX channel\n                if curr_ch == AX1 or curr_ch == AX2:\n                    f.a[index] = (\n                        int.from_bytes(\n                            bf[byte_it : byte_it + 4], byteorder=\"little\"\n                        )\n                        &amp; 0xFFFFFF\n                    )\n                    byte_it += 3\n                    if convert:\n                        f.mv[index] = ((f.a[index]) * (3.3*2) / (pow(2, 24) - 1))*1000\n                        f.mv[index] = round(f.mv[index], 3)\n\n                # If it's an AI channel\n                else:\n                    if not mid_frame_flag:\n                        f.a[index] = (\n                            int.from_bytes(\n                                bf[byte_it : byte_it + 2], byteorder=\"little\"\n                            )\n                            &amp; 0xFFF\n                        )\n                        byte_it += 1\n                        mid_frame_flag = 1\n                    else:\n                        f.a[index] = (\n                            int.from_bytes(\n                                bf[byte_it : byte_it + 2], byteorder=\"little\"\n                            )\n                            &gt;&gt; 4\n                        )\n                        byte_it += 2\n                        mid_frame_flag = 0\n                    if convert:\n                        f.mv[index] = self.__adc1_chars.esp_adc_cal_raw_to_voltage(\n                            f.a[index]\n                        )\n        elif self.__api_mode == API_MODE_JSON:\n            print(bf)\n        else:\n            raise NotSupportedError()\n\n        start += self.__packet_size\n\n    if len(frames) == self.__num_frames:\n        if not matrix:\n            return frames\n        else:\n            return np.array([frame.to_matrix() for frame in frames])\n    else:\n        raise ContactingDeviceError()\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.start","title":"<code>start(sample_rate, channels, reads_per_second=5, simulated=False)</code>","text":"<p>Starts a signal acquisition from the device</p> <p>Parameters:</p> Name Type Description Default <code>sample_rate</code> <code>int</code> <p>Sampling rate in Hz.</p> <p>Accepted values are 1, 10, 100 or 1000 Hz.</p> required <code>channels</code> <code>list</code> <p>Set of channels to acquire.</p> <p>Accepted channels are 1...6 for inputs A1...A6.</p> required <code>reads_per_second</code> <code>int</code> <p>Number of times to read the data streaming from the device.</p> <p>Accepted values are integers greater than 0.</p> <code>5</code> <code>simulated</code> <code>bool</code> <p>If true, start in simulated mode.</p> <p>Otherwise start in live mode. Default is to start in live mode.</p> <code>False</code> <p>Raises:</p> Type Description <code>DeviceNotIdleError</code> <p>If the device is already in acquisition mode.</p> <code>InvalidParameterError</code> <p>If no valid API value is chosen or an incorrect array of channels is provided.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def start(\n    self,\n    sample_rate,\n    channels,\n    reads_per_second=5,\n    simulated=False,\n):\n\"\"\"\n    Starts a signal acquisition from the device\n\n    Args:\n        sample_rate (int): Sampling rate in Hz.\n\n            Accepted values are 1, 10, 100 or 1000 Hz.\n\n        channels (list): Set of channels to acquire.\n\n            Accepted channels are 1...6 for inputs A1...A6.\n\n        reads_per_second (int): Number of times to read the data streaming from the device.\n\n            Accepted values are integers greater than 0.\n\n\n        simulated (bool): If true, start in simulated mode.\n\n            Otherwise start in live mode. Default is to start in live mode.\n\n    Raises:\n        DeviceNotIdleError: If the device is already in acquisition mode.\n        InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided.\n    \"\"\"\n    assert int(reads_per_second) &gt; 0\n\n    if self.__num_chs != 0:\n        raise DeviceNotIdleError()\n\n    if not channels:  # channels is empty\n        chMask = 0xFF  #  all 8 analog channels\n        self.__num_chs = 8\n    else:\n        chMask = 0\n        for ch in channels:\n            if ch &lt;= 0 or ch &gt; 8:\n                raise InvalidParameterError()\n            self.__chs[self.__num_chs] = ch  # Fill chs vector\n\n            mask = 1 &lt;&lt; (ch - 1)\n            if chMask &amp; mask:\n                self.__num_chs = 0\n                raise InvalidParameterError()\n\n            chMask |= mask\n            self.__num_chs += 1\n\n    self.__sample_rate = sample_rate\n\n    # Sample rate\n    sr = 0b01000011\n    sr |= self.__sample_rate &lt;&lt; 8\n    self.__send(sr, 4)\n\n    # Cleanup existing data in bluetooth socket\n    self.__clear()\n\n    if simulated:\n        cmd = 0x02\n    else:\n        cmd = 0x01\n    cmd |= chMask &lt;&lt; 8\n\n    self.__send(cmd)\n\n    self.__packet_size = self.__getPacketSize()\n\n    self.__bytes_to_read = self.__packet_size * max(\n        sample_rate // reads_per_second, 1\n    )\n    if self.__bytes_to_read &gt; MAX_BUFFER_SIZE:\n        self.__bytes_to_read = MAX_BUFFER_SIZE - (\n            MAX_BUFFER_SIZE % self.__packet_size\n        )\n\n    if self.__bytes_to_read % self.__packet_size:\n        self.__num_chs = 0\n        sys.stderr.write(\n            \"Error, bytes_to_read needs to be devisible by packet_size\\n\"\n        )\n        raise InvalidParameterError()\n    else:\n        self.__num_frames = self.__bytes_to_read // self.__packet_size\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.state","title":"<code>state()</code>","text":"<p>Returns current device state (%ScientISST 2 only).</p> <p>Returns:</p> Name Type Description <code>state</code> <code>State</code> <p>Current device <code>State</code></p> <p>Raises:</p> Type Description <code>DeviceNotIdleError</code> <p>If the device is in acquisition mode.</p> <code>ContactingDeviceError</code> <p>If there is an error contacting the device.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def state(self):\n\"\"\"\n    Returns current device state (%ScientISST 2 only).\n\n    Returns:\n        state (State): Current device [`State`][scientisst.state.State]\n\n    Raises:\n        DeviceNotIdleError: If the device is in acquisition mode.\n        ContactingDeviceError: If there is an error contacting the device.\n    \"\"\"\n    if self.__num_chs != 0:\n        raise DeviceNotIdleError()\n\n    cmd = 0x0B\n    self.__send(cmd)\n    # 0  0  0  0  1  0  1  1 - Send device status\n\n    # if (recv(&amp;statex, sizeof statex) != sizeof statex)    # a timeout has occurred\n    # throw Exception(Exception::CONTACTING_DEVICE);\n    result = self.__recv(16)\n    if not result or not self.__checkCRC4(result, 16):\n        raise ContactingDeviceError()\n\n    state = State()\n    print(result)\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.stop","title":"<code>stop()</code>","text":"<p>Stops a signal acquisition.</p> <p>Raises:</p> Type Description <code>DeviceNotInAcquisitionError</code> <p>If the device is not in acquisition mode.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def stop(self):\n\"\"\"\n    Stops a signal acquisition.\n\n    Raises:\n        DeviceNotInAcquisitionError: If the device is not in acquisition mode.\n    \"\"\"\n    if self.__num_chs == 0:\n        raise DeviceNotInAcquisitionError()\n\n    cmd = b\"\\x00\"\n    self.__send(cmd)  # 0  0  0  0  0  0  0  0 - Go to idle mode\n\n    self.__num_chs = 0\n    self.__sample_rate = 0\n\n    # Cleanup existing data in bluetooth socket\n    self.__clear()\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.trigger","title":"<code>trigger(digital_output)</code>","text":"<p>Assigns the digital outputs states.</p> <p>Parameters:</p> Name Type Description Default <code>digital_output</code> <code>list</code> <p>Vector of booleans to assign to digital outputs, starting at first output (O1).</p> required <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the length of the digital_output array is different from 2.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def trigger(self, digital_output):\n\"\"\"\n    Assigns the digital outputs states.\n\n    Args:\n        digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1).\n\n    Raises:\n        InvalidParameterError: If the length of the digital_output array is different from 2.\n    \"\"\"\n    length = len(digital_output)\n\n    if length != 2:\n        raise InvalidParameterError()\n\n    cmd = 0xB3  # 1  0  1  1  O2 O1 1  1 - Set digital outputs\n\n    for i in range(length):\n        if digital_output[i]:\n            cmd |= 0b100 &lt;&lt; i\n\n    self.__send(cmd)\n</code></pre>"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.version_and_adc_chars","title":"<code>version_and_adc_chars(print=True)</code>","text":"<p>Gets the device firmware version string and esp_adc_characteristics</p> <p>Returns:</p> Name Type Description <code>version</code> <code>str</code> <p>Firmware version</p> <p>Raises:</p> Type Description <code>ContactingDeviceError</code> <p>If there is an error contacting the device.</p> Source code in <code>scientisst/scientisst.py</code> <pre><code>def version_and_adc_chars(self, print=True):\n\"\"\"\n    Gets the device firmware version string and esp_adc_characteristics\n\n    Returns:\n        version (str): Firmware version\n\n    Raises:\n        ContactingDeviceError: If there is an error contacting the device.\n    \"\"\"\n    if self.__api_mode == API_MODE_BITALINO:\n        header = \"BITalino\"\n    else:\n        header = \"ScientISST\"\n    header_len = len(header)\n\n    cmd = b\"\\x07\"\n    self.__send(cmd)\n\n    result = self.__recv(1024, waitall_flag=False)\n\n    if result == b\"\":\n        raise ContactingDeviceError()\n\n    index = result.index(b\"\\x00\")\n    version = result[header_len : index - 1].decode(\"utf-8\")\n\n    self.__adc1_chars = EspAdcCalChars(result[index + 1 :])\n\n    if print:\n        sys.stdout.write(\"ScientISST version: {}\\n\".format(version))\n        sys.stdout.write(\n            \"ScientISST Board Vref: {}\\n\".format(self.__adc1_chars.vref)\n        )\n        sys.stdout.write(\n            \"ScientISST Board ADC Attenuation Mode: {}\\n\".format(\n                self.__adc1_chars.atten\n            )\n        )\n\n    return version\n</code></pre>"},{"location":"reference/state-reference/","title":"State","text":""},{"location":"reference/state-reference/#scientisst.state.State","title":"<code>State</code>","text":"<p>ScientISST Device State class</p> <p>A state returned by ScientISST.state()</p> Source code in <code>scientisst/state.py</code> <pre><code>class State:\n\"\"\"\n    ScientISST Device State class\n\n    A state returned by ScientISST.state()\n\n    \"\"\"\n\n    a = [0] * 8\n    digital = [0] * 4\n    battery = None\n    bat_threshold = None\n</code></pre>"}]}