{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"scientisst-sense-api-python The ScientISST SENSE Python API. Here you can find everything about this Python API: Installation Getting Started Reference","title":"Home"},{"location":"#scientisst-sense-api-python","text":"The ScientISST SENSE Python API. Here you can find everything about this Python API: Installation Getting Started Reference","title":"scientisst-sense-api-python"},{"location":"installation/","text":"Installation Clone the Repo # Getting this repository git clone https://github.com/scientisst/scientisst-sense-api-python.git Dependencies PySerial Install it using pip : pip install pyserial Start using it!","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#clone-the-repo","text":"# Getting this repository git clone https://github.com/scientisst/scientisst-sense-api-python.git","title":"Clone the Repo"},{"location":"installation/#dependencies","text":"PySerial Install it using pip : pip install pyserial Start using it!","title":"Dependencies"},{"location":"getting-started/api/","text":"Examples Connect to Device The following code creates a Scientisst object and establishes a connection to the specified device. scientisst = ScientISST ( \"08:3A:F2:49:AB:DE\" ) Print Version The following code prints the firmware version of the device connected with the previous command. scientisst . version () Acquisition The following snippet starts streaming data from channels A1 , A2 , and A3 at 100 Hz. Then, it reads the streaming data (by default, for frequencies not too high, 5 times per second) and prints the first Frame . After reading 1000 frames, it stops the acquisition. scientisst . start ( 100 , [ 1 , 2 , 3 ]) for i in range ( 50 ): frames = scientisst . read () print ( frames [ 0 ]) scientisst . stop () Disconnect Once you no longer want to use the ScientISST device, you must dispose it: scientisst . disconnect ()","title":"API"},{"location":"getting-started/api/#examples","text":"","title":"Examples"},{"location":"getting-started/api/#connect-to-device","text":"The following code creates a Scientisst object and establishes a connection to the specified device. scientisst = ScientISST ( \"08:3A:F2:49:AB:DE\" )","title":"Connect to Device"},{"location":"getting-started/api/#print-version","text":"The following code prints the firmware version of the device connected with the previous command. scientisst . version ()","title":"Print Version"},{"location":"getting-started/api/#acquisition","text":"The following snippet starts streaming data from channels A1 , A2 , and A3 at 100 Hz. Then, it reads the streaming data (by default, for frequencies not too high, 5 times per second) and prints the first Frame . After reading 1000 frames, it stops the acquisition. scientisst . start ( 100 , [ 1 , 2 , 3 ]) for i in range ( 50 ): frames = scientisst . read () print ( frames [ 0 ]) scientisst . stop ()","title":"Acquisition"},{"location":"getting-started/api/#disconnect","text":"Once you no longer want to use the ScientISST device, you must dispose it: scientisst . disconnect ()","title":"Disconnect"},{"location":"getting-started/sense/","text":"sense.py is a script that simplifies the interaction with the ScientISST Sense. It allows the selection of channels, sampling rate, and duration right from the command line. It also implements file data saving in the background (using a different thread) and also streaming via Lab Streaming Layer (LSL). Dependencies scientisst - ScientISST Sense Python API pylsl (optional) - Used for streaming with LSL Usage Options $ python sense.py -h usage: sense.py [args] address description: The program connects to the ScientISST Sense device and starts an acquisition, providing the option to store the received data in a .csv file. positional arguments: address Linux: bluetooth MAC address, Mac: serial port address, Windows: bluetooth serial COM port options: -h, --help show this help message and exit -f FS, --frequency FS sampling frequency, default: 1000 -c CHANNELS, --channels CHANNELS analog channels, default: 1,2,3,4,5,6 -d DURATION, --duration DURATION duration in seconds, default: unlimited -o OUTPUT, --output OUTPUT write report to output file, default: None -r, --raw do not convert from raw to mV -s, --lsl stream data using Lab Streaming Layer protocol. Use `python -m pylsl.examples.ReceiveAndPlot` to view stream -q, --quiet don't print ScientISST frames -v, --version show sense.py version --verbose log sent/received bytes Automatic Selection Pair your device Run: python sense.py Select the device from the list displayed: ScientISST devices: [1] ScientISST-ab-de - 08:3A:F2:49:AB:DE [2] ScientISST-ac-be - 08:3A:F2:49:AC:BE Connect to: Then hit CTRL-C when you wish to stop. Manual Selection Linux Pair and trust the ScientISST Sense board: bluetoothctl scan on pair XX:XX:XX:XX:XX trust XX:XX:XX:XX:XX You can now run the sense.py script: python sense.py XX:XX:XX:XX:XX Mac First, you need to pair the ScientISST sense device in the Bluetooth Settings section. Then, you'll need to find the serial port address using the Terminal: ls /dev/tty.ScientISST* Copy the String like: /dev/tty.ScientISST-XX-XX-SPP_SE . You can now run the sense.py script: python sense.py /dev/tty.ScientISST-XX-XX-SPP_SE Windows Turn the ScientISST Sense board on. Now, go to Control Panel > Hardware and Sound > Devices and Printers. Select \"Add a device\". Select the ScientISST Sense board, hit \"next\" until its set up. While connected to the board, search \"Bluetooth settings\" on the Control Panel, then go to the \"COM ports\" tab and check the port name for the outgoing entry. Copy the String like: COMX You can now run the sense.py script: python sense.py COMX Examples Single Channel The following snippet will start streaming channel A1 : python sense.py -c 1 Frequency The following snippet will start streaming channel A1 at 100 Hz: python sense.py -c 1 -f 100 Multiple Channels The following snippet will start streaming channels A1 , A2 , A3 , A4 : python sense.py -c 1,2,3,4 Save to File The following snippet will start recording the default channels ( A1 , A2 , A3 , A4 , A5 , A6 ) to the file output.csv : python sense.py -o output.csv Duration The following snippet will start recording the default channels for 10 seconds : python sense.py -o output.csv -d 10 Lab Streaming Layer The following snippet will start streaming the default channels using LSL : python sense.py -s Visualize the streaming data using: python -m pylsl.examples.ReceiveAndPlot","title":"sense.py"},{"location":"getting-started/sense/#dependencies","text":"scientisst - ScientISST Sense Python API pylsl (optional) - Used for streaming with LSL","title":"Dependencies"},{"location":"getting-started/sense/#usage-options","text":"$ python sense.py -h usage: sense.py [args] address description: The program connects to the ScientISST Sense device and starts an acquisition, providing the option to store the received data in a .csv file. positional arguments: address Linux: bluetooth MAC address, Mac: serial port address, Windows: bluetooth serial COM port options: -h, --help show this help message and exit -f FS, --frequency FS sampling frequency, default: 1000 -c CHANNELS, --channels CHANNELS analog channels, default: 1,2,3,4,5,6 -d DURATION, --duration DURATION duration in seconds, default: unlimited -o OUTPUT, --output OUTPUT write report to output file, default: None -r, --raw do not convert from raw to mV -s, --lsl stream data using Lab Streaming Layer protocol. Use `python -m pylsl.examples.ReceiveAndPlot` to view stream -q, --quiet don't print ScientISST frames -v, --version show sense.py version --verbose log sent/received bytes","title":"Usage Options"},{"location":"getting-started/sense/#automatic-selection","text":"Pair your device Run: python sense.py Select the device from the list displayed: ScientISST devices: [1] ScientISST-ab-de - 08:3A:F2:49:AB:DE [2] ScientISST-ac-be - 08:3A:F2:49:AC:BE Connect to: Then hit CTRL-C when you wish to stop.","title":"Automatic Selection"},{"location":"getting-started/sense/#manual-selection","text":"","title":"Manual Selection"},{"location":"getting-started/sense/#linux","text":"Pair and trust the ScientISST Sense board: bluetoothctl scan on pair XX:XX:XX:XX:XX trust XX:XX:XX:XX:XX You can now run the sense.py script: python sense.py XX:XX:XX:XX:XX","title":"Linux"},{"location":"getting-started/sense/#mac","text":"First, you need to pair the ScientISST sense device in the Bluetooth Settings section. Then, you'll need to find the serial port address using the Terminal: ls /dev/tty.ScientISST* Copy the String like: /dev/tty.ScientISST-XX-XX-SPP_SE . You can now run the sense.py script: python sense.py /dev/tty.ScientISST-XX-XX-SPP_SE","title":"Mac"},{"location":"getting-started/sense/#windows","text":"Turn the ScientISST Sense board on. Now, go to Control Panel > Hardware and Sound > Devices and Printers. Select \"Add a device\". Select the ScientISST Sense board, hit \"next\" until its set up. While connected to the board, search \"Bluetooth settings\" on the Control Panel, then go to the \"COM ports\" tab and check the port name for the outgoing entry. Copy the String like: COMX You can now run the sense.py script: python sense.py COMX","title":"Windows"},{"location":"getting-started/sense/#examples","text":"","title":"Examples"},{"location":"getting-started/sense/#single-channel","text":"The following snippet will start streaming channel A1 : python sense.py -c 1","title":"Single Channel"},{"location":"getting-started/sense/#frequency","text":"The following snippet will start streaming channel A1 at 100 Hz: python sense.py -c 1 -f 100","title":"Frequency"},{"location":"getting-started/sense/#multiple-channels","text":"The following snippet will start streaming channels A1 , A2 , A3 , A4 : python sense.py -c 1,2,3,4","title":"Multiple Channels"},{"location":"getting-started/sense/#save-to-file","text":"The following snippet will start recording the default channels ( A1 , A2 , A3 , A4 , A5 , A6 ) to the file output.csv : python sense.py -o output.csv","title":"Save to File"},{"location":"getting-started/sense/#duration","text":"The following snippet will start recording the default channels for 10 seconds : python sense.py -o output.csv -d 10","title":"Duration"},{"location":"getting-started/sense/#lab-streaming-layer","text":"The following snippet will start streaming the default channels using LSL : python sense.py -s Visualize the streaming data using: python -m pylsl.examples.ReceiveAndPlot","title":"Lab Streaming Layer"},{"location":"reference/exceptions-reference/","text":"BTAdapterNotFoundError ( Exception ) No Bluetooth adapter was found. Source code in scientisst/exceptions.py class BTAdapterNotFoundError ( Exception ): \"\"\" No Bluetooth adapter was found. \"\"\" def __init__ ( self ): super () . __init__ ( \"No Bluetooth adapter was found.\" ) ContactingDeviceError ( Exception ) The computer lost communication with the device. Source code in scientisst/exceptions.py class ContactingDeviceError ( Exception ): \"\"\" The computer lost communication with the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"The computer lost communication with the device.\" ) DeviceNotFoundError ( Exception ) The device could not be found. Source code in scientisst/exceptions.py class DeviceNotFoundError ( Exception ): \"\"\" The device could not be found. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device could not be found.\" ) DeviceNotIdleError ( Exception ) The device is not idle. Source code in scientisst/exceptions.py class DeviceNotIdleError ( Exception ): \"\"\" The device is not idle. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not idle.\" ) DeviceNotInAcquisitionError ( Exception ) The device is not in acquisition mode. Source code in scientisst/exceptions.py class DeviceNotInAcquisitionError ( Exception ): \"\"\" The device is not in acquisition mode. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not in acquisition mode.\" ) InvalidAddressError ( Exception ) The specified address is invalid. Source code in scientisst/exceptions.py class InvalidAddressError ( Exception ): \"\"\" The specified address is invalid. \"\"\" def __init__ ( self ): super () . __init__ ( \"The specified address is invalid.\" ) InvalidParameterError ( Exception ) Invalid parameter. Source code in scientisst/exceptions.py class InvalidParameterError ( Exception ): \"\"\" Invalid parameter. \"\"\" def __init__ ( self ): super () . __init__ ( \"Invalid parameter.\" ) NotSupportedError ( Exception ) Operation not supported by the device. Source code in scientisst/exceptions.py class NotSupportedError ( Exception ): \"\"\" Operation not supported by the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"Operation not supported by the device.\" ) PortCouldNotBeOpenedError ( Exception ) The communication port does not exist or it is already being used. Source code in scientisst/exceptions.py class PortCouldNotBeOpenedError ( Exception ): \"\"\" The communication port does not exist or it is already being used. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port does not exist or it is already being used.\" ) PortInitializationError ( Exception ) The communication port could not be initialized. Source code in scientisst/exceptions.py class PortInitializationError ( Exception ): \"\"\" The communication port could not be initialized. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port could not be initialized.\" ) UnknownError ( Exception ) Unknown error: message . Source code in scientisst/exceptions.py class UnknownError ( Exception ): \"\"\" Unknown error: `message`. \"\"\" def __init__ ( self , message = \"\" ): super () . __init__ ( \"Unknown error: {} \" . format ( message ))","title":"Exceptions"},{"location":"reference/exceptions-reference/#scientisst.exceptions.BTAdapterNotFoundError","text":"No Bluetooth adapter was found. Source code in scientisst/exceptions.py class BTAdapterNotFoundError ( Exception ): \"\"\" No Bluetooth adapter was found. \"\"\" def __init__ ( self ): super () . __init__ ( \"No Bluetooth adapter was found.\" )","title":"BTAdapterNotFoundError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.ContactingDeviceError","text":"The computer lost communication with the device. Source code in scientisst/exceptions.py class ContactingDeviceError ( Exception ): \"\"\" The computer lost communication with the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"The computer lost communication with the device.\" )","title":"ContactingDeviceError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotFoundError","text":"The device could not be found. Source code in scientisst/exceptions.py class DeviceNotFoundError ( Exception ): \"\"\" The device could not be found. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device could not be found.\" )","title":"DeviceNotFoundError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotIdleError","text":"The device is not idle. Source code in scientisst/exceptions.py class DeviceNotIdleError ( Exception ): \"\"\" The device is not idle. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not idle.\" )","title":"DeviceNotIdleError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.DeviceNotInAcquisitionError","text":"The device is not in acquisition mode. Source code in scientisst/exceptions.py class DeviceNotInAcquisitionError ( Exception ): \"\"\" The device is not in acquisition mode. \"\"\" def __init__ ( self ): super () . __init__ ( \"The device is not in acquisition mode.\" )","title":"DeviceNotInAcquisitionError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.InvalidAddressError","text":"The specified address is invalid. Source code in scientisst/exceptions.py class InvalidAddressError ( Exception ): \"\"\" The specified address is invalid. \"\"\" def __init__ ( self ): super () . __init__ ( \"The specified address is invalid.\" )","title":"InvalidAddressError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.InvalidParameterError","text":"Invalid parameter. Source code in scientisst/exceptions.py class InvalidParameterError ( Exception ): \"\"\" Invalid parameter. \"\"\" def __init__ ( self ): super () . __init__ ( \"Invalid parameter.\" )","title":"InvalidParameterError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.NotSupportedError","text":"Operation not supported by the device. Source code in scientisst/exceptions.py class NotSupportedError ( Exception ): \"\"\" Operation not supported by the device. \"\"\" def __init__ ( self ): super () . __init__ ( \"Operation not supported by the device.\" )","title":"NotSupportedError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.PortCouldNotBeOpenedError","text":"The communication port does not exist or it is already being used. Source code in scientisst/exceptions.py class PortCouldNotBeOpenedError ( Exception ): \"\"\" The communication port does not exist or it is already being used. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port does not exist or it is already being used.\" )","title":"PortCouldNotBeOpenedError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.PortInitializationError","text":"The communication port could not be initialized. Source code in scientisst/exceptions.py class PortInitializationError ( Exception ): \"\"\" The communication port could not be initialized. \"\"\" def __init__ ( self ): super () . __init__ ( \"The communication port could not be initialized.\" )","title":"PortInitializationError"},{"location":"reference/exceptions-reference/#scientisst.exceptions.UnknownError","text":"Unknown error: message . Source code in scientisst/exceptions.py class UnknownError ( Exception ): \"\"\" Unknown error: `message`. \"\"\" def __init__ ( self , message = \"\" ): super () . __init__ ( \"Unknown error: {} \" . format ( message ))","title":"UnknownError"},{"location":"reference/frame-reference/","text":"Frame ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: Name Type Description seq int Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital list Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a list Array of raw analog inputs values of the active channles. If all channels are active, a will have 8 elements: 6 AIs and 2 AXs. mv list Array of analog inputs values of the active channles in mV. If all channels are active, mv will have 8 elements: 6 AIs and 2 AXs. Source code in scientisst/frame.py class Frame : \"\"\" ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: seq (int): Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital (list): Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a (list): Array of raw analog inputs values of the active channles. If all channels are active, `a` will have 8 elements: 6 AIs and 2 AXs. mv (list): Array of analog inputs values of the active channles in mV. If all channels are active, `mv` will have 8 elements: 6 AIs and 2 AXs. \"\"\" digital = [ 0 ] * 4 seq = - 1 a = None mv = None def __init__ ( self , num_frames ): self . a = [ None ] * num_frames self . mv = [ None ] * num_frames def toMap ( self ): return { \"sequence\" : self . seq , \"analog\" : self . a , \"digital\" : self . digital , \"mv\" : self . mv , } def toString ( self ): return str ( self . toMap ()) def __str__ ( self ): if self . mv [ 0 ]: values = [ str ( val ) for pair in zip ( self . a , self . mv ) for val in pair ] else : values = map ( str , self . a ) return \" {} \\t {} \\t {} \\t {} \\t {} \\t {} \" . format ( self . seq , self . digital [ 0 ], self . digital [ 1 ], self . digital [ 2 ], self . digital [ 3 ], \" \\t \" . join ( values ), )","title":"Frame"},{"location":"reference/frame-reference/#scientisst.frame.Frame","text":"ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: Name Type Description seq int Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital list Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a list Array of raw analog inputs values of the active channles. If all channels are active, a will have 8 elements: 6 AIs and 2 AXs. mv list Array of analog inputs values of the active channles in mV. If all channels are active, mv will have 8 elements: 6 AIs and 2 AXs. Source code in scientisst/frame.py class Frame : \"\"\" ScientISST Device Frame class A frame returned by ScientISST.read() Attributes: seq (int): Frame sequence number (0...15). This number is incremented by 1 on each consecutive frame, and it overflows to 0 after 15 (it is a 4-bit number). This number can be used to detect if frames were dropped while transmitting data. digital (list): Array of digital ports states (False for low level or True for high level). On original ScientISST, the array contents are: I1 I2 I3 I4. On ScientISST 2, the array contents are: I1 I2 O1 O2. a (list): Array of raw analog inputs values of the active channles. If all channels are active, `a` will have 8 elements: 6 AIs and 2 AXs. mv (list): Array of analog inputs values of the active channles in mV. If all channels are active, `mv` will have 8 elements: 6 AIs and 2 AXs. \"\"\" digital = [ 0 ] * 4 seq = - 1 a = None mv = None def __init__ ( self , num_frames ): self . a = [ None ] * num_frames self . mv = [ None ] * num_frames def toMap ( self ): return { \"sequence\" : self . seq , \"analog\" : self . a , \"digital\" : self . digital , \"mv\" : self . mv , } def toString ( self ): return str ( self . toMap ()) def __str__ ( self ): if self . mv [ 0 ]: values = [ str ( val ) for pair in zip ( self . a , self . mv ) for val in pair ] else : values = map ( str , self . a ) return \" {} \\t {} \\t {} \\t {} \\t {} \\t {} \" . format ( self . seq , self . digital [ 0 ], self . digital [ 1 ], self . digital [ 2 ], self . digital [ 3 ], \" \\t \" . join ( values ), )","title":"Frame"},{"location":"reference/scientisst-reference/","text":"ScientISST ScientISST Device class Attributes: Name Type Description address str The device serial port address (\"/dev/example\") serial_speed int The serial port bitrate. Source code in scientisst/scientisst.py class ScientISST : \"\"\"ScientISST Device class Attributes: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate. \"\"\" __serial = None __socket = None __num_chs = 0 __api_mode = 1 __sample_rate = None __chs = [ None ] * 8 __log = False def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () sys . stdout . write ( \"Connected! \\n \" ) def version_and_adc_chars ( self ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) adc1_chars = EspAdcCalChars ( result [ index + 1 :]) # Initialize fields for lookup table if necessary if adc1_chars . atten == ADC_ATTEN_DB_11 : if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . low_curve = LUT_ADC1_LOW else : adc1_chars . low_curve = LUT_ADC2_LOW if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . high_curve = LUT_ADC1_HIGH else : adc1_chars . high_curve = LUT_ADC2_HIGH else : adc1_chars . low_curve = 0 adc1_chars . high_curve = 0 self . __adc1_chars = adc1_chars sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( adc1_chars . vref )) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( adc1_chars . atten ) ) return version def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size def read ( self , convert = True ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = int ( esp_adc_cal_raw_to_voltage ( f . a [ index ], self . __adc1_chars ) * VOLT_DIVIDER_FACTOR ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : return frames else : raise ContactingDeviceError () def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear () def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd ) def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd ) def dac ( self , pwm_output ): \"\"\" Assigns the analog (PWM) output value (ScientISST 2 only). Args: pwm_output (int): Analog output value to set (0...255). Raises: InvalidParameterError: If the pwm_output value is outside of its range, 0-255. \"\"\" if pwm_output < 0 or pwm_output > 255 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output cmd |= pwm_output << 8 self . __send ( cmd ) # TODO: test with ScientISST Sense v2 def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result ) # for(int i = 0; i < 6; i++) # state.analog[i] = statex.analog[i]; # state.battery = statex.battery; # state.batThreshold = statex.batThreshold; # for(int i = 0; i < 4; i++) # state.digital[i] = ((statex.portsCRC & (0x80 >> i)) != 0); # return state; def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" ) def __getPacketSize ( self ): packet_size = 0 if self . __api_mode == API_MODE_SCIENTISST : num_intern_active_chs = 0 num_extern_active_chs = 0 for ch in self . __chs : if ch : # Add 24bit channel's contributuion to packet size if ch == AX1 or ch == AX2 : num_extern_active_chs += 1 # Count 12bit channels else : num_intern_active_chs += 1 # Add 24bit channel's contributuion to packet size packet_size = 3 * num_extern_active_chs # Add 12bit channel's contributuion to packet size if not ( num_intern_active_chs % 2 ): # If it's an even number packet_size += ( num_intern_active_chs * 12 ) / 8 else : packet_size += ( ( num_intern_active_chs * 12 ) - 4 ) / 8 # -4 because 4 bits can go in the I/0 byte # for the I/Os and seq+crc bytes packet_size += 2 elif self . __api_mode == API_MODE_JSON : for i in range ( self . __num_chs ): # If it's internal ch if self . __chs [ i ] <= 6 : # sprintf(aux_str, \"AI%d\", chs[i]); # member_name.SetString(aux_str, d.GetAllocator()); # member_value.SetString(value_internal_str, d.GetAllocator()); # d.AddMember(member_name, member_value, d.GetAllocator()); packet_size += 3 # AI%d packet_size += 2 # 0-4095 = 12 bits <= 2 bytes else : packet_size += 3 # AX%d packet_size += 4 # 0-16777215 = 24 bits <= 4 bytes # Add IO state json objects # d.AddMember(\"I1\", \"0\", d.GetAllocator()); # d.AddMember(\"I2\", \"0\", d.GetAllocator()); # d.AddMember(\"O1\", \"0\", d.GetAllocator()); # d.AddMember(\"O2\", \"0\", d.GetAllocator()); packet_size += 3 # I1 + 0|1 packet_size += 3 # I2 + 0|1 packet_size += 3 # O1 + 0|1 packet_size += 3 # O1 + 0|1 else : raise NotSupportedError () return int ( packet_size ) def __changeAPI ( self , api ): if self . __num_chs and self . __num_chs != 0 : raise DeviceNotIdleError () if api <= 0 or api > 3 : raise InvalidParameterError () self . __api_mode = api api <<= 4 api |= 0b11 self . __send ( api ) def __checkCRC4 ( self , data , length ): CRC4tab = [ 0 , 3 , 6 , 5 , 12 , 15 , 10 , 9 , 11 , 8 , 13 , 14 , 7 , 4 , 1 , 2 ] crc = 0 for i in range ( length - 1 ): b = data [ i ] crc = CRC4tab [ crc ] ^ ( b >> 4 ) crc = CRC4tab [ crc ] ^ ( b & 0x0F ) # CRC for last byte crc = CRC4tab [ crc ] ^ ( data [ - 1 ] >> 4 ) crc = CRC4tab [ crc ] return crc == ( data [ - 1 ] & 0x0F ) def __send ( self , command , nrOfBytes = None ): \"\"\" Send data \"\"\" if type ( command ) is int : if command != 0 : command = command . to_bytes ( int ( log2 ( command ) // 8 + 1 ), byteorder = \"little\" ) else : command = b \" \\x00 \" if nrOfBytes and len ( command ) < nrOfBytes : for _ in range ( nrOfBytes - len ( command )): command += b \" \\x00 \" # if self.__serial: time . sleep ( 0.250 ) if self . __log : sys . stdout . write ( \" {} bytes sent: {} \\n \" . format ( len ( command ), \" \" . join ( \" {:02x} \" . format ( c ) for c in command ) ) ) if self . __socket : self . __socket . send ( command ) else : self . __serial . write ( command ) # else: # raise ContactingDeviceError() def __recv ( self , nrOfBytes ): \"\"\" Receive data \"\"\" result = None if self . __socket : result = self . __socket . recv ( nrOfBytes , socket . MSG_WAITALL ) else : result = self . __serial . read ( nrOfBytes ) if self . __log : if nrOfBytes > 1 : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( nrOfBytes , \" \" . join ( \" {:02x} \" . format ( c ) for c in result ) ) ) else : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( 1 , result . hex ())) return result def __clear ( self ): \"\"\" Clear the device buffer \"\"\" if self . __socket : self . __socket . setblocking ( False ) else : self . __serial . timeout = 0 try : while self . __recv ( 1 ): pass except BlockingIOError : pass if self . __socket : self . __socket . setblocking ( True ) else : self . __serial . timeout = TIMEOUT_IN_SECONDS __init__ ( self , address , serial_speed = 115200 , log = False , api = 2 ) special Parameters: Name Type Description Default address str The device serial port address (\"/dev/example\") required serial_speed int The serial port bitrate in bit/s 115200 log bool If the bytes sent and received should be showed False api int The desired API mode for the device 2 Source code in scientisst/scientisst.py def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () sys . stdout . write ( \"Connected! \\n \" ) battery ( self , value = 0 ) Sets the battery voltage threshold for the low-battery LED. Parameters: Name Type Description Default value int Battery voltage threshold. Default value is 0. Value Voltage Threshold 0 3.4 V ... ... 63 3.8 V 0 Exceptions: Type Description DeviceNotIdleError If the device is in acquisition mode. InvalidParameterError If an invalid battery threshold value is given. Source code in scientisst/scientisst.py def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd ) dac ( self , pwm_output ) Assigns the analog (PWM) output value (ScientISST 2 only). Parameters: Name Type Description Default pwm_output int Analog output value to set (0...255). required Exceptions: Type Description InvalidParameterError If the pwm_output value is outside of its range, 0-255. Source code in scientisst/scientisst.py def dac ( self , pwm_output ): \"\"\" Assigns the analog (PWM) output value (ScientISST 2 only). Args: pwm_output (int): Analog output value to set (0...255). Raises: InvalidParameterError: If the pwm_output value is outside of its range, 0-255. \"\"\" if pwm_output < 0 or pwm_output > 255 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output cmd |= pwm_output << 8 self . __send ( cmd ) disconnect ( self ) Disconnects from a ScientISST device. If an aquisition is running, it is stopped Source code in scientisst/scientisst.py def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" ) read ( self , convert = True ) Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Parameters: Name Type Description Default convert bool Convert from raw to mV True Returns: Type Description frames (list) List of Frame objects retrieved from the device Exceptions: Type Description ContactingDeviceError If there is an error contacting the device. DeviceNotInAcquisitionError If the device is not in acquisition mode. NotSupportedError If the device API is in BITALINO mode UnknownError If the device stopped sending frames for some unknown reason. Source code in scientisst/scientisst.py def read ( self , convert = True ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = int ( esp_adc_cal_raw_to_voltage ( f . a [ index ], self . __adc1_chars ) * VOLT_DIVIDER_FACTOR ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : return frames else : raise ContactingDeviceError () start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False ) Starts a signal acquisition from the device Parameters: Name Type Description Default sample_rate int Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. required channels list Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. required reads_per_second int Number of times to read the data streaming from the device. Accepted values are integers greater than 0. 5 simulated bool If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. False Exceptions: Type Description DeviceNotIdleError If the device is already in acquisition mode. InvalidParameterError If no valid API value is chosen or an incorrect array of channels is provided. Source code in scientisst/scientisst.py def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size state ( self ) Returns current device state (%ScientISST 2 only). Returns: Type Description state (State) Current device State Exceptions: Type Description DeviceNotIdleError If the device is in acquisition mode. ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result ) stop ( self ) Stops a signal acquisition. Exceptions: Type Description DeviceNotInAcquisitionError If the device is not in acquisition mode. Source code in scientisst/scientisst.py def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear () trigger ( self , digital_output ) Assigns the digital outputs states. Parameters: Name Type Description Default digital_output list Vector of booleans to assign to digital outputs, starting at first output (O1). required Exceptions: Type Description InvalidParameterError If the length of the digital_output array is different from 2. Source code in scientisst/scientisst.py def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd ) version_and_adc_chars ( self ) Gets the device firmware version string and esp_adc_characteristics Returns: Type Description version (str) Firmware version Exceptions: Type Description ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py def version_and_adc_chars ( self ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) adc1_chars = EspAdcCalChars ( result [ index + 1 :]) # Initialize fields for lookup table if necessary if adc1_chars . atten == ADC_ATTEN_DB_11 : if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . low_curve = LUT_ADC1_LOW else : adc1_chars . low_curve = LUT_ADC2_LOW if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . high_curve = LUT_ADC1_HIGH else : adc1_chars . high_curve = LUT_ADC2_HIGH else : adc1_chars . low_curve = 0 adc1_chars . high_curve = 0 self . __adc1_chars = adc1_chars sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( adc1_chars . vref )) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( adc1_chars . atten ) ) return version","title":"ScientISST"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST","text":"ScientISST Device class Attributes: Name Type Description address str The device serial port address (\"/dev/example\") serial_speed int The serial port bitrate. Source code in scientisst/scientisst.py class ScientISST : \"\"\"ScientISST Device class Attributes: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate. \"\"\" __serial = None __socket = None __num_chs = 0 __api_mode = 1 __sample_rate = None __chs = [ None ] * 8 __log = False def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () sys . stdout . write ( \"Connected! \\n \" ) def version_and_adc_chars ( self ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) adc1_chars = EspAdcCalChars ( result [ index + 1 :]) # Initialize fields for lookup table if necessary if adc1_chars . atten == ADC_ATTEN_DB_11 : if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . low_curve = LUT_ADC1_LOW else : adc1_chars . low_curve = LUT_ADC2_LOW if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . high_curve = LUT_ADC1_HIGH else : adc1_chars . high_curve = LUT_ADC2_HIGH else : adc1_chars . low_curve = 0 adc1_chars . high_curve = 0 self . __adc1_chars = adc1_chars sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( adc1_chars . vref )) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( adc1_chars . atten ) ) return version def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size def read ( self , convert = True ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = int ( esp_adc_cal_raw_to_voltage ( f . a [ index ], self . __adc1_chars ) * VOLT_DIVIDER_FACTOR ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : return frames else : raise ContactingDeviceError () def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear () def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd ) def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd ) def dac ( self , pwm_output ): \"\"\" Assigns the analog (PWM) output value (ScientISST 2 only). Args: pwm_output (int): Analog output value to set (0...255). Raises: InvalidParameterError: If the pwm_output value is outside of its range, 0-255. \"\"\" if pwm_output < 0 or pwm_output > 255 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output cmd |= pwm_output << 8 self . __send ( cmd ) # TODO: test with ScientISST Sense v2 def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result ) # for(int i = 0; i < 6; i++) # state.analog[i] = statex.analog[i]; # state.battery = statex.battery; # state.batThreshold = statex.batThreshold; # for(int i = 0; i < 4; i++) # state.digital[i] = ((statex.portsCRC & (0x80 >> i)) != 0); # return state; def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" ) def __getPacketSize ( self ): packet_size = 0 if self . __api_mode == API_MODE_SCIENTISST : num_intern_active_chs = 0 num_extern_active_chs = 0 for ch in self . __chs : if ch : # Add 24bit channel's contributuion to packet size if ch == AX1 or ch == AX2 : num_extern_active_chs += 1 # Count 12bit channels else : num_intern_active_chs += 1 # Add 24bit channel's contributuion to packet size packet_size = 3 * num_extern_active_chs # Add 12bit channel's contributuion to packet size if not ( num_intern_active_chs % 2 ): # If it's an even number packet_size += ( num_intern_active_chs * 12 ) / 8 else : packet_size += ( ( num_intern_active_chs * 12 ) - 4 ) / 8 # -4 because 4 bits can go in the I/0 byte # for the I/Os and seq+crc bytes packet_size += 2 elif self . __api_mode == API_MODE_JSON : for i in range ( self . __num_chs ): # If it's internal ch if self . __chs [ i ] <= 6 : # sprintf(aux_str, \"AI%d\", chs[i]); # member_name.SetString(aux_str, d.GetAllocator()); # member_value.SetString(value_internal_str, d.GetAllocator()); # d.AddMember(member_name, member_value, d.GetAllocator()); packet_size += 3 # AI%d packet_size += 2 # 0-4095 = 12 bits <= 2 bytes else : packet_size += 3 # AX%d packet_size += 4 # 0-16777215 = 24 bits <= 4 bytes # Add IO state json objects # d.AddMember(\"I1\", \"0\", d.GetAllocator()); # d.AddMember(\"I2\", \"0\", d.GetAllocator()); # d.AddMember(\"O1\", \"0\", d.GetAllocator()); # d.AddMember(\"O2\", \"0\", d.GetAllocator()); packet_size += 3 # I1 + 0|1 packet_size += 3 # I2 + 0|1 packet_size += 3 # O1 + 0|1 packet_size += 3 # O1 + 0|1 else : raise NotSupportedError () return int ( packet_size ) def __changeAPI ( self , api ): if self . __num_chs and self . __num_chs != 0 : raise DeviceNotIdleError () if api <= 0 or api > 3 : raise InvalidParameterError () self . __api_mode = api api <<= 4 api |= 0b11 self . __send ( api ) def __checkCRC4 ( self , data , length ): CRC4tab = [ 0 , 3 , 6 , 5 , 12 , 15 , 10 , 9 , 11 , 8 , 13 , 14 , 7 , 4 , 1 , 2 ] crc = 0 for i in range ( length - 1 ): b = data [ i ] crc = CRC4tab [ crc ] ^ ( b >> 4 ) crc = CRC4tab [ crc ] ^ ( b & 0x0F ) # CRC for last byte crc = CRC4tab [ crc ] ^ ( data [ - 1 ] >> 4 ) crc = CRC4tab [ crc ] return crc == ( data [ - 1 ] & 0x0F ) def __send ( self , command , nrOfBytes = None ): \"\"\" Send data \"\"\" if type ( command ) is int : if command != 0 : command = command . to_bytes ( int ( log2 ( command ) // 8 + 1 ), byteorder = \"little\" ) else : command = b \" \\x00 \" if nrOfBytes and len ( command ) < nrOfBytes : for _ in range ( nrOfBytes - len ( command )): command += b \" \\x00 \" # if self.__serial: time . sleep ( 0.250 ) if self . __log : sys . stdout . write ( \" {} bytes sent: {} \\n \" . format ( len ( command ), \" \" . join ( \" {:02x} \" . format ( c ) for c in command ) ) ) if self . __socket : self . __socket . send ( command ) else : self . __serial . write ( command ) # else: # raise ContactingDeviceError() def __recv ( self , nrOfBytes ): \"\"\" Receive data \"\"\" result = None if self . __socket : result = self . __socket . recv ( nrOfBytes , socket . MSG_WAITALL ) else : result = self . __serial . read ( nrOfBytes ) if self . __log : if nrOfBytes > 1 : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( nrOfBytes , \" \" . join ( \" {:02x} \" . format ( c ) for c in result ) ) ) else : sys . stdout . write ( \" {} bytes received: {} \\n \" . format ( 1 , result . hex ())) return result def __clear ( self ): \"\"\" Clear the device buffer \"\"\" if self . __socket : self . __socket . setblocking ( False ) else : self . __serial . timeout = 0 try : while self . __recv ( 1 ): pass except BlockingIOError : pass if self . __socket : self . __socket . setblocking ( True ) else : self . __serial . timeout = TIMEOUT_IN_SECONDS","title":"ScientISST"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.__init__","text":"Parameters: Name Type Description Default address str The device serial port address (\"/dev/example\") required serial_speed int The serial port bitrate in bit/s 115200 log bool If the bytes sent and received should be showed False api int The desired API mode for the device 2 Source code in scientisst/scientisst.py def __init__ ( self , address , serial_speed = 115200 , log = False , api = API_MODE_SCIENTISST ): \"\"\" Args: address (str): The device serial port address (\"/dev/example\") serial_speed (int, optional): The serial port bitrate in bit/s log (bool, optional): If the bytes sent and received should be showed api (int): The desired API mode for the device \"\"\" if sys . platform == \"linux\" : if not re . match ( \"[0-9a-f] {2} ([-:]?)[0-9a-f] {2} ( \\\\ 1[0-9a-f] {2} ) {4} $\" , address . lower () ): raise InvalidAddressError () if ( api != API_MODE_SCIENTISST and api != API_MODE_JSON and api != API_MODE_BITALINO ): raise InvalidParameterError () self . address = address self . speed = serial_speed self . __log = log sys . stdout . write ( \"Connecting to {} ... \\n \" . format ( address )) # Create the client socket if sys . platform == \"linux\" : self . __socket = socket . socket ( socket . AF_BLUETOOTH , socket . SOCK_STREAM , socket . BTPROTO_RFCOMM ) self . __socket . settimeout ( TIMEOUT_IN_SECONDS ) self . __socket . connect (( address , 1 )) else : self . __serial = serial . Serial ( address , serial_speed , timeout = TIMEOUT_IN_SECONDS ) # Set API mode self . __changeAPI ( api ) # get device version string and adc characteristics self . version_and_adc_chars () sys . stdout . write ( \"Connected! \\n \" )","title":"__init__()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.battery","text":"Sets the battery voltage threshold for the low-battery LED. Parameters: Name Type Description Default value int Battery voltage threshold. Default value is 0. Value Voltage Threshold 0 3.4 V ... ... 63 3.8 V 0 Exceptions: Type Description DeviceNotIdleError If the device is in acquisition mode. InvalidParameterError If an invalid battery threshold value is given. Source code in scientisst/scientisst.py def battery ( self , value = 0 ): \"\"\" Sets the battery voltage threshold for the low-battery LED. Args: value (int): Battery voltage threshold. Default value is 0. Value | Voltage Threshold ----- | ----------------- 0 | 3.4 V ... | ... 63 | 3.8 V Raises: DeviceNotIdleError: If the device is in acquisition mode. InvalidParameterError: If an invalid battery threshold value is given. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () if value < 0 or value > 63 : raise InvalidParameterError () cmd = value << 2 # <bat threshold> 0 0 - Set battery threshold self . __send ( cmd )","title":"battery()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.dac","text":"Assigns the analog (PWM) output value (ScientISST 2 only). Parameters: Name Type Description Default pwm_output int Analog output value to set (0...255). required Exceptions: Type Description InvalidParameterError If the pwm_output value is outside of its range, 0-255. Source code in scientisst/scientisst.py def dac ( self , pwm_output ): \"\"\" Assigns the analog (PWM) output value (ScientISST 2 only). Args: pwm_output (int): Analog output value to set (0...255). Raises: InvalidParameterError: If the pwm_output value is outside of its range, 0-255. \"\"\" if pwm_output < 0 or pwm_output > 255 : raise InvalidParameterError () cmd = 0xA3 # 1 0 1 0 0 0 1 1 - Set dac output cmd |= pwm_output << 8 self . __send ( cmd )","title":"dac()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.disconnect","text":"Disconnects from a ScientISST device. If an aquisition is running, it is stopped Source code in scientisst/scientisst.py def disconnect ( self ): \"\"\" Disconnects from a ScientISST device. If an aquisition is running, it is stopped \"\"\" if self . __num_chs != 0 : self . stop () if self . __socket : self . __socket . close () self . __socket = None elif self . __serial : self . __serial . close () self . __serial = None sys . stdout . write ( \"Disconnected \\n \" )","title":"disconnect()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.read","text":"Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Parameters: Name Type Description Default convert bool Convert from raw to mV True Returns: Type Description frames (list) List of Frame objects retrieved from the device Exceptions: Type Description ContactingDeviceError If there is an error contacting the device. DeviceNotInAcquisitionError If the device is not in acquisition mode. NotSupportedError If the device API is in BITALINO mode UnknownError If the device stopped sending frames for some unknown reason. Source code in scientisst/scientisst.py def read ( self , convert = True ): \"\"\" Reads acquisition frames from the device. This method returns when all requested frames are received from the device, or when a timeout occurs. Args: convert (bool): Convert from raw to mV Returns: frames (list): List of [`Frame`][scientisst.frame.Frame] objects retrieved from the device Raises: ContactingDeviceError: If there is an error contacting the device. DeviceNotInAcquisitionError: If the device is not in acquisition mode. NotSupportedError: If the device API is in BITALINO mode UnknownError: If the device stopped sending frames for some unknown reason. \"\"\" frames = [ None ] * self . __num_frames if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () result = list ( self . __recv ( self . __bytes_to_read )) start = 0 for it in range ( self . __num_frames ): bf = result [ start : start + self . __packet_size ] mid_frame_flag = 0 # if CRC check failed, try to resynchronize with the next valid frame while not self . __checkCRC4 ( bf , self . __packet_size ): sys . stderr . write ( \"Error checking CRC4\" ) # checking with one new byte at a time result_tmp = list ( self . __recv ( 1 )) if len ( result_tmp ) != 1 : raise ContactingDeviceError () result += result_tmp start += 1 bf = result [ start : start + self . __packet_size ] f = Frame ( self . __num_chs ) frames [ it ] = f if self . __api_mode == API_MODE_SCIENTISST : # Get seq number and IO states f . seq = bf [ - 1 ] >> 4 for i in range ( 4 ): f . digital [ i ] = 0 if ( bf [ - 2 ] & ( 0x80 >> i )) == 0 else 1 # Get channel values byte_it = 0 for i in range ( self . __num_chs ): index = self . __num_chs - 1 - i curr_ch = self . __chs [ index ] # If it's an AX channel if curr_ch == AX1 or curr_ch == AX2 : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 4 ], byteorder = \"little\" ) & 0xFFFFFF ) byte_it += 3 # If it's an AI channel else : if not mid_frame_flag : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) & 0xFFF ) byte_it += 1 mid_frame_flag = 1 else : f . a [ index ] = ( int . from_bytes ( bf [ byte_it : byte_it + 2 ], byteorder = \"little\" ) >> 4 ) byte_it += 2 mid_frame_flag = 0 if convert : f . mv [ index ] = int ( esp_adc_cal_raw_to_voltage ( f . a [ index ], self . __adc1_chars ) * VOLT_DIVIDER_FACTOR ) elif self . __api_mode == API_MODE_JSON : print ( bf ) else : raise NotSupportedError () start += self . __packet_size if len ( frames ) == self . __num_frames : return frames else : raise ContactingDeviceError ()","title":"read()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.start","text":"Starts a signal acquisition from the device Parameters: Name Type Description Default sample_rate int Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. required channels list Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. required reads_per_second int Number of times to read the data streaming from the device. Accepted values are integers greater than 0. 5 simulated bool If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. False Exceptions: Type Description DeviceNotIdleError If the device is already in acquisition mode. InvalidParameterError If no valid API value is chosen or an incorrect array of channels is provided. Source code in scientisst/scientisst.py def start ( self , sample_rate , channels , reads_per_second = 5 , simulated = False , ): \"\"\" Starts a signal acquisition from the device Args: sample_rate (int): Sampling rate in Hz. Accepted values are 1, 10, 100 or 1000 Hz. channels (list): Set of channels to acquire. Accepted channels are 1...6 for inputs A1...A6. reads_per_second (int): Number of times to read the data streaming from the device. Accepted values are integers greater than 0. simulated (bool): If true, start in simulated mode. Otherwise start in live mode. Default is to start in live mode. Raises: DeviceNotIdleError: If the device is already in acquisition mode. InvalidParameterError: If no valid API value is chosen or an incorrect array of channels is provided. \"\"\" assert int ( reads_per_second ) > 0 if self . __num_chs != 0 : raise DeviceNotIdleError () if not channels : # channels is empty chMask = 0xFF # all 8 analog channels self . __num_chs = 8 else : chMask = 0 for ch in channels : if ch <= 0 or ch > 8 : raise InvalidParameterError () self . __chs [ self . __num_chs ] = ch # Fill chs vector mask = 1 << ( ch - 1 ) if chMask & mask : self . __num_chs = 0 raise InvalidParameterError () chMask |= mask self . __num_chs += 1 self . __sample_rate = sample_rate # Sample rate sr = 0b01000011 sr |= self . __sample_rate << 8 self . __send ( sr , 4 ) # Cleanup existing data in bluetooth socket self . __clear () if simulated : cmd = 0x02 else : cmd = 0x01 cmd |= chMask << 8 self . __send ( cmd ) self . __packet_size = self . __getPacketSize () self . __bytes_to_read = self . __packet_size * max ( sample_rate // reads_per_second , 1 ) if self . __bytes_to_read > MAX_BUFFER_SIZE : self . __bytes_to_read = MAX_BUFFER_SIZE - ( MAX_BUFFER_SIZE % self . __packet_size ) if self . __bytes_to_read % self . __packet_size : self . __num_chs = 0 sys . stderr . write ( \"Error, bytes_to_read needs to be devisible by packet_size \\n \" ) raise InvalidParameterError () else : self . __num_frames = self . __bytes_to_read // self . __packet_size","title":"start()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.state","text":"Returns current device state (%ScientISST 2 only). Returns: Type Description state (State) Current device State Exceptions: Type Description DeviceNotIdleError If the device is in acquisition mode. ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py def state ( self ): \"\"\" Returns current device state (%ScientISST 2 only). Returns: state (State): Current device [`State`][scientisst.state.State] Raises: DeviceNotIdleError: If the device is in acquisition mode. ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __num_chs != 0 : raise DeviceNotIdleError () cmd = 0x0B self . __send ( cmd ) # 0 0 0 0 1 0 1 1 - Send device status # if (recv(&statex, sizeof statex) != sizeof statex) # a timeout has occurred # throw Exception(Exception::CONTACTING_DEVICE); result = self . __recv ( 16 ) if not result or not self . __checkCRC4 ( result , 16 ): raise ContactingDeviceError () state = State () print ( result )","title":"state()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.stop","text":"Stops a signal acquisition. Exceptions: Type Description DeviceNotInAcquisitionError If the device is not in acquisition mode. Source code in scientisst/scientisst.py def stop ( self ): \"\"\" Stops a signal acquisition. Raises: DeviceNotInAcquisitionError: If the device is not in acquisition mode. \"\"\" if self . __num_chs == 0 : raise DeviceNotInAcquisitionError () cmd = b \" \\x00 \" self . __send ( cmd ) # 0 0 0 0 0 0 0 0 - Go to idle mode self . __num_chs = 0 self . __sample_rate = 0 # Cleanup existing data in bluetooth socket self . __clear ()","title":"stop()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.trigger","text":"Assigns the digital outputs states. Parameters: Name Type Description Default digital_output list Vector of booleans to assign to digital outputs, starting at first output (O1). required Exceptions: Type Description InvalidParameterError If the length of the digital_output array is different from 2. Source code in scientisst/scientisst.py def trigger ( self , digital_output ): \"\"\" Assigns the digital outputs states. Args: digital_output (list): Vector of booleans to assign to digital outputs, starting at first output (O1). Raises: InvalidParameterError: If the length of the digital_output array is different from 2. \"\"\" length = len ( digital_output ) if length != 2 : raise InvalidParameterError () cmd = 0xB3 # 1 0 1 1 O2 O1 1 1 - Set digital outputs for i in range ( length ): if digital_output [ i ]: cmd |= 0b100 << i self . __send ( cmd )","title":"trigger()"},{"location":"reference/scientisst-reference/#scientisst.scientisst.ScientISST.version_and_adc_chars","text":"Gets the device firmware version string and esp_adc_characteristics Returns: Type Description version (str) Firmware version Exceptions: Type Description ContactingDeviceError If there is an error contacting the device. Source code in scientisst/scientisst.py def version_and_adc_chars ( self ): \"\"\" Gets the device firmware version string and esp_adc_characteristics Returns: version (str): Firmware version Raises: ContactingDeviceError: If there is an error contacting the device. \"\"\" if self . __api_mode == API_MODE_BITALINO : header = \"BITalino\" else : header = \"ScientISST\" header_len = len ( header ) cmd = b \" \\x07 \" self . __send ( cmd ) result = self . __recv ( 1024 ) if result == b \"\" : raise ContactingDeviceError () index = result . index ( b \" \\x00 \" ) version = result [ header_len : index - 1 ] . decode ( \"utf-8\" ) adc1_chars = EspAdcCalChars ( result [ index + 1 :]) # Initialize fields for lookup table if necessary if adc1_chars . atten == ADC_ATTEN_DB_11 : if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . low_curve = LUT_ADC1_LOW else : adc1_chars . low_curve = LUT_ADC2_LOW if adc1_chars . adc_num == ADC_UNIT_1 : adc1_chars . high_curve = LUT_ADC1_HIGH else : adc1_chars . high_curve = LUT_ADC2_HIGH else : adc1_chars . low_curve = 0 adc1_chars . high_curve = 0 self . __adc1_chars = adc1_chars sys . stdout . write ( \"ScientISST version: {} \\n \" . format ( version )) sys . stdout . write ( \"ScientISST Board Vref: {} \\n \" . format ( adc1_chars . vref )) sys . stdout . write ( \"ScientISST Board ADC Attenuation Mode: {} \\n \" . format ( adc1_chars . atten ) ) return version","title":"version_and_adc_chars()"},{"location":"reference/state-reference/","text":"State ScientISST Device State class A state returned by ScientISST.state() Source code in scientisst/state.py class State : \"\"\" ScientISST Device State class A state returned by ScientISST.state() \"\"\" a = [ 0 ] * 8 digital = [ 0 ] * 4 battery = None bat_threshold = None","title":"State"},{"location":"reference/state-reference/#scientisst.state.State","text":"ScientISST Device State class A state returned by ScientISST.state() Source code in scientisst/state.py class State : \"\"\" ScientISST Device State class A state returned by ScientISST.state() \"\"\" a = [ 0 ] * 8 digital = [ 0 ] * 4 battery = None bat_threshold = None","title":"State"}]}